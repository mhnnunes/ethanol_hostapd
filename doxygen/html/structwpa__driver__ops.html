<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Ethanol modification of Hostapd: wpa_driver_ops Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Ethanol modification of Hostapd
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structwpa__driver__ops-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">wpa_driver_ops Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="driver_8h_source.html">driver.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for wpa_driver_ops:</div>
<div class="dyncontent">
<div class="center"><img src="structwpa__driver__ops__coll__graph.png" border="0" usemap="#wpa__driver__ops_coll__map" alt="Collaboration graph"/></div>
<map name="wpa__driver__ops_coll__map" id="wpa__driver__ops_coll__map">
<area shape="rect" id="node2" href="structwpa__scan__results.html" title="wpa_scan_results" alt="" coords="54,189,180,216"/><area shape="rect" id="node3" href="structwpa__scan__res.html" title="wpa_scan_res" alt="" coords="5,99,112,125"/><area shape="rect" id="node4" href="structos__reltime.html" title="os_reltime" alt="" coords="136,99,217,125"/><area shape="rect" id="node5" href="structwpa__interface__info.html" title="wpa_interface_info" alt="" coords="205,189,335,216"/><area shape="rect" id="node6" href="structhostapd__hw__modes.html" title="hostapd_hw_modes" alt="" coords="413,189,552,216"/><area shape="rect" id="node7" href="structhostapd__channel__data.html" title="hostapd_channel_data" alt="" coords="407,99,559,125"/><area shape="rect" id="node8" href="structdl__list.html" title="dl_list" alt="" coords="455,7,509,33"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a91ef3e58a1174b2a412e4d50ce1dea63"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a91ef3e58a1174b2a412e4d50ce1dea63">name</a></td></tr>
<tr class="separator:a91ef3e58a1174b2a412e4d50ce1dea63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b9089a419658b8f958097b676e4832"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a12b9089a419658b8f958097b676e4832">desc</a></td></tr>
<tr class="separator:a12b9089a419658b8f958097b676e4832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb69d901da34f5810ffe76b0d6a01b4"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#abcb69d901da34f5810ffe76b0d6a01b4">get_bssid</a> )(void *priv, u8 *bssid)</td></tr>
<tr class="separator:abcb69d901da34f5810ffe76b0d6a01b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55c366c5799ee641689724967b7de15"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#ae55c366c5799ee641689724967b7de15">get_ssid</a> )(void *priv, u8 *ssid)</td></tr>
<tr class="separator:ae55c366c5799ee641689724967b7de15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7011114b84f8cac06bfb4a54e5ec43e"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#aa7011114b84f8cac06bfb4a54e5ec43e">set_key</a> )(const char *ifname, void *priv, enum wpa_alg alg, const u8 *addr, int key_idx, int set_tx, const u8 *seq, size_t seq_len, const u8 *key, size_t key_len)</td></tr>
<tr class="separator:aa7011114b84f8cac06bfb4a54e5ec43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247e66445054de570b291854b1b4de2d"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a247e66445054de570b291854b1b4de2d">init</a> )(void *ctx, const char *ifname)</td></tr>
<tr class="separator:a247e66445054de570b291854b1b4de2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c9a92dc2061694c7b9baa8423b5f8a"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a80c9a92dc2061694c7b9baa8423b5f8a">deinit</a> )(void *priv)</td></tr>
<tr class="separator:a80c9a92dc2061694c7b9baa8423b5f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11566ca9790ee3da508cc3d221c50230"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a11566ca9790ee3da508cc3d221c50230">set_param</a> )(void *priv, const char *param)</td></tr>
<tr class="separator:a11566ca9790ee3da508cc3d221c50230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624aa6019f0a29c3a977edf524f24f0a"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a624aa6019f0a29c3a977edf524f24f0a">set_countermeasures</a> )(void *priv, int enabled)</td></tr>
<tr class="separator:a624aa6019f0a29c3a977edf524f24f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6447201e96d72b23d2e7b0c5d1d86c6a"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a6447201e96d72b23d2e7b0c5d1d86c6a">deauthenticate</a> )(void *priv, const u8 *addr, int reason_code)</td></tr>
<tr class="separator:a6447201e96d72b23d2e7b0c5d1d86c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2985f9322b4e24f53508a164479d62"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#aab2985f9322b4e24f53508a164479d62">associate</a> )(void *priv, struct <a class="el" href="structwpa__driver__associate__params.html">wpa_driver_associate_params</a> *params)</td></tr>
<tr class="separator:aab2985f9322b4e24f53508a164479d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593e2b92abdd987eeb27c03e6a830137"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a593e2b92abdd987eeb27c03e6a830137">add_pmkid</a> )(void *priv, const u8 *bssid, const u8 *pmkid)</td></tr>
<tr class="separator:a593e2b92abdd987eeb27c03e6a830137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5101fd0e80c8343439c6741facb9f7d6"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a5101fd0e80c8343439c6741facb9f7d6">remove_pmkid</a> )(void *priv, const u8 *bssid, const u8 *pmkid)</td></tr>
<tr class="separator:a5101fd0e80c8343439c6741facb9f7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea95b5c762f95b0dd1d3870753278a5"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a7ea95b5c762f95b0dd1d3870753278a5">flush_pmkid</a> )(void *priv)</td></tr>
<tr class="separator:a7ea95b5c762f95b0dd1d3870753278a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d87ddf442ba6643db82bbb7eded00fe"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a4d87ddf442ba6643db82bbb7eded00fe">get_capa</a> )(void *priv, struct <a class="el" href="structwpa__driver__capa.html">wpa_driver_capa</a> *capa)</td></tr>
<tr class="separator:a4d87ddf442ba6643db82bbb7eded00fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9577cd055c0e48faa08be273119127"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a7b9577cd055c0e48faa08be273119127">poll</a> )(void *priv)</td></tr>
<tr class="separator:a7b9577cd055c0e48faa08be273119127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b727bb678254f2a5d907528ccad677"><td class="memItemLeft" align="right" valign="top">unsigned int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a32b727bb678254f2a5d907528ccad677">get_ifindex</a> )(void *priv)</td></tr>
<tr class="separator:a32b727bb678254f2a5d907528ccad677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09913aed5ecc094f48120a152303311e"><td class="memItemLeft" align="right" valign="top">const char *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a09913aed5ecc094f48120a152303311e">get_ifname</a> )(void *priv)</td></tr>
<tr class="separator:a09913aed5ecc094f48120a152303311e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab410829ac706da13b57cbf63c0368895"><td class="memItemLeft" align="right" valign="top">const u8 *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#ab410829ac706da13b57cbf63c0368895">get_mac_addr</a> )(void *priv)</td></tr>
<tr class="separator:ab410829ac706da13b57cbf63c0368895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab822dded24230639aff78955355bf022"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#ab822dded24230639aff78955355bf022">set_operstate</a> )(void *priv, int state)</td></tr>
<tr class="separator:ab822dded24230639aff78955355bf022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94994ed8eac24845ee5be54320e7d2a7"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a94994ed8eac24845ee5be54320e7d2a7">mlme_setprotection</a> )(void *priv, const u8 *addr, int protect_type, int key_type)</td></tr>
<tr class="separator:a94994ed8eac24845ee5be54320e7d2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99845a556a35e4cd53b58f13ad0154c4"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structhostapd__hw__modes.html">hostapd_hw_modes</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a99845a556a35e4cd53b58f13ad0154c4">get_hw_feature_data</a> )(void *priv, u16 *num_modes, u16 *flags)</td></tr>
<tr class="separator:a99845a556a35e4cd53b58f13ad0154c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc17be00e77c9133ac3e0f451d3b286b"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#acc17be00e77c9133ac3e0f451d3b286b">send_mlme</a> )(void *priv, const u8 *data, size_t data_len, int noack, unsigned int <a class="el" href="structfreq.html">freq</a>, const u16 *csa_offs, size_t csa_offs_len)</td></tr>
<tr class="separator:acc17be00e77c9133ac3e0f451d3b286b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e8395f5f46a07d705020f2a2cf80f8"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#aa0e8395f5f46a07d705020f2a2cf80f8">update_ft_ies</a> )(void *priv, const u8 *md, const u8 *ies, size_t ies_len)</td></tr>
<tr class="separator:aa0e8395f5f46a07d705020f2a2cf80f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058e8d7899cc93a6ebd97a58f4499d3b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structwpa__scan__results.html">wpa_scan_results</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a058e8d7899cc93a6ebd97a58f4499d3b">get_scan_results2</a> )(void *priv)</td></tr>
<tr class="separator:a058e8d7899cc93a6ebd97a58f4499d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ae4fc64d0507ebdf0e1c98875b5184"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#aa9ae4fc64d0507ebdf0e1c98875b5184">set_country</a> )(void *priv, const char *alpha2)</td></tr>
<tr class="separator:aa9ae4fc64d0507ebdf0e1c98875b5184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62682a2eae7dd228fa12cd536adcdbd7"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a62682a2eae7dd228fa12cd536adcdbd7">get_country</a> )(void *priv, char *alpha2)</td></tr>
<tr class="separator:a62682a2eae7dd228fa12cd536adcdbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603c9fc1c7ce20dce68d6f377782c446"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a603c9fc1c7ce20dce68d6f377782c446">global_init</a> )(void *ctx)</td></tr>
<tr class="separator:a603c9fc1c7ce20dce68d6f377782c446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef740f80e92476d296dbc51b336cbfa7"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#aef740f80e92476d296dbc51b336cbfa7">global_deinit</a> )(void *priv)</td></tr>
<tr class="separator:aef740f80e92476d296dbc51b336cbfa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce383ea8244702f503f4fbdd7402011"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a7ce383ea8244702f503f4fbdd7402011">init2</a> )(void *ctx, const char *ifname, void *global_priv)</td></tr>
<tr class="separator:a7ce383ea8244702f503f4fbdd7402011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b47e7dbef5d8830421893fc17995db"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structwpa__interface__info.html">wpa_interface_info</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a30b47e7dbef5d8830421893fc17995db">get_interfaces</a> )(void *global_priv)</td></tr>
<tr class="separator:a30b47e7dbef5d8830421893fc17995db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0accf1567d49af5b20b6344189e72b"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a0a0accf1567d49af5b20b6344189e72b">scan2</a> )(void *priv, struct <a class="el" href="structwpa__driver__scan__params.html">wpa_driver_scan_params</a> *params)</td></tr>
<tr class="separator:a0a0accf1567d49af5b20b6344189e72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3679419d9276dace431505a93647db"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a5f3679419d9276dace431505a93647db">authenticate</a> )(void *priv, struct <a class="el" href="structwpa__driver__auth__params.html">wpa_driver_auth_params</a> *params)</td></tr>
<tr class="separator:a5f3679419d9276dace431505a93647db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565bd07356ac6f552a692cfd72b448ec"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a565bd07356ac6f552a692cfd72b448ec">set_ap</a> )(void *priv, struct <a class="el" href="structwpa__driver__ap__params.html">wpa_driver_ap_params</a> *params)</td></tr>
<tr class="separator:a565bd07356ac6f552a692cfd72b448ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d7fb4d5cb7ec7f9d2c208486e326c0"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a14d7fb4d5cb7ec7f9d2c208486e326c0">set_acl</a> )(void *priv, struct <a class="el" href="structhostapd__acl__params.html">hostapd_acl_params</a> *params)</td></tr>
<tr class="separator:a14d7fb4d5cb7ec7f9d2c208486e326c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa031fa85b113d12a6a2ee27b456fa444"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#aa031fa85b113d12a6a2ee27b456fa444">hapd_init</a> )(struct <a class="el" href="structhostapd__data.html">hostapd_data</a> *hapd, struct <a class="el" href="structwpa__init__params.html">wpa_init_params</a> *params)</td></tr>
<tr class="separator:aa031fa85b113d12a6a2ee27b456fa444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7881f78182d904efa2f2ec514441fce0"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a7881f78182d904efa2f2ec514441fce0">hapd_deinit</a> )(void *priv)</td></tr>
<tr class="separator:a7881f78182d904efa2f2ec514441fce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a96b55cccf5b13306c2f1ec6ad00834"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a5a96b55cccf5b13306c2f1ec6ad00834">set_ieee8021x</a> )(void *priv, struct <a class="el" href="structwpa__bss__params.html">wpa_bss_params</a> *params)</td></tr>
<tr class="separator:a5a96b55cccf5b13306c2f1ec6ad00834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9e5e75655df6b41f95ec143ac0c1fe"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#acd9e5e75655df6b41f95ec143ac0c1fe">set_privacy</a> )(void *priv, int enabled)</td></tr>
<tr class="separator:acd9e5e75655df6b41f95ec143ac0c1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95c6ff890ea90e68239bc94cf87c140"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#ab95c6ff890ea90e68239bc94cf87c140">get_seqnum</a> )(const char *ifname, void *priv, const u8 *addr, int idx, u8 *seq)</td></tr>
<tr class="separator:ab95c6ff890ea90e68239bc94cf87c140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad82e7ac6e660ed0db8abb18f89eb29"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a6ad82e7ac6e660ed0db8abb18f89eb29">flush</a> )(void *priv)</td></tr>
<tr class="separator:a6ad82e7ac6e660ed0db8abb18f89eb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22098eada1a8802e56bf2651a5eb5516"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a22098eada1a8802e56bf2651a5eb5516">set_generic_elem</a> )(void *priv, const u8 *elem, size_t elem_len)</td></tr>
<tr class="separator:a22098eada1a8802e56bf2651a5eb5516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6afc2b66c0ec459b7b052502c03fad4"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#ab6afc2b66c0ec459b7b052502c03fad4">read_sta_data</a> )(void *priv, struct <a class="el" href="structhostap__sta__driver__data.html">hostap_sta_driver_data</a> *data, const u8 *addr)</td></tr>
<tr class="separator:ab6afc2b66c0ec459b7b052502c03fad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d10bb9b3c7049f2a36cd95a158f2ee6"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a5d10bb9b3c7049f2a36cd95a158f2ee6">hapd_send_eapol</a> )(void *priv, const u8 *addr, const u8 *data, size_t data_len, int encrypt, const u8 *own_addr, u32 flags)</td></tr>
<tr class="separator:a5d10bb9b3c7049f2a36cd95a158f2ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da84de2fb37cbf5e5f58fc2029bd90e"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a4da84de2fb37cbf5e5f58fc2029bd90e">sta_deauth</a> )(void *priv, const u8 *own_addr, const u8 *addr, int reason)</td></tr>
<tr class="separator:a4da84de2fb37cbf5e5f58fc2029bd90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8c3154617e6071ca13c4bdf1672101"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#acf8c3154617e6071ca13c4bdf1672101">sta_disassoc</a> )(void *priv, const u8 *own_addr, const u8 *addr, int reason)</td></tr>
<tr class="separator:acf8c3154617e6071ca13c4bdf1672101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac518b3ba9121879cbd5b935ddd18a495"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#ac518b3ba9121879cbd5b935ddd18a495">sta_remove</a> )(void *priv, const u8 *addr)</td></tr>
<tr class="separator:ac518b3ba9121879cbd5b935ddd18a495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384c895e21715325244ba3471b715a4c"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a384c895e21715325244ba3471b715a4c">hapd_get_ssid</a> )(void *priv, u8 *buf, int len)</td></tr>
<tr class="separator:a384c895e21715325244ba3471b715a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d13d02abfc6b19fd0b9f01bcb2db76f"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a5d13d02abfc6b19fd0b9f01bcb2db76f">hapd_set_ssid</a> )(void *priv, const u8 *buf, int len)</td></tr>
<tr class="separator:a5d13d02abfc6b19fd0b9f01bcb2db76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200de14c5ce1da387dfbb7b6354d2b13"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a200de14c5ce1da387dfbb7b6354d2b13">hapd_set_countermeasures</a> )(void *priv, int enabled)</td></tr>
<tr class="separator:a200de14c5ce1da387dfbb7b6354d2b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe2c644ed40d088200d2f12530ff1d7"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#abbe2c644ed40d088200d2f12530ff1d7">sta_add</a> )(void *priv, struct <a class="el" href="structhostapd__sta__add__params.html">hostapd_sta_add_params</a> *params)</td></tr>
<tr class="separator:abbe2c644ed40d088200d2f12530ff1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ab96d480d1908fc8371269e4edc1e0"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#af7ab96d480d1908fc8371269e4edc1e0">get_inact_sec</a> )(void *priv, const u8 *addr)</td></tr>
<tr class="separator:af7ab96d480d1908fc8371269e4edc1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5570c6efea13d6d8c0c6212968ec9022"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a5570c6efea13d6d8c0c6212968ec9022">sta_clear_stats</a> )(void *priv, const u8 *addr)</td></tr>
<tr class="separator:a5570c6efea13d6d8c0c6212968ec9022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f78a8a4580531be375b0f99c5848eeb"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a5f78a8a4580531be375b0f99c5848eeb">set_freq</a> )(void *priv, struct <a class="el" href="structhostapd__freq__params.html">hostapd_freq_params</a> *<a class="el" href="structfreq.html">freq</a>)</td></tr>
<tr class="separator:a5f78a8a4580531be375b0f99c5848eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ceeac95efc0eed7247f1af0165c9ca"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a09ceeac95efc0eed7247f1af0165c9ca">set_rts</a> )(void *priv, int rts)</td></tr>
<tr class="separator:a09ceeac95efc0eed7247f1af0165c9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294bd2b3887e938595ba24025cc82ded"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a294bd2b3887e938595ba24025cc82ded">set_frag</a> )(void *priv, int frag)</td></tr>
<tr class="separator:a294bd2b3887e938595ba24025cc82ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af982067929096b4955e1281fa5fdd2c1"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#af982067929096b4955e1281fa5fdd2c1">sta_set_flags</a> )(void *priv, const u8 *addr, unsigned int total_flags, unsigned int flags_or, unsigned int flags_and)</td></tr>
<tr class="separator:af982067929096b4955e1281fa5fdd2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afda74c5da7d5497888c365c98bd6e5"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a8afda74c5da7d5497888c365c98bd6e5">set_tx_queue_params</a> )(void *priv, int queue, int aifs, int cw_min, int cw_max, int burst_time)</td></tr>
<tr class="separator:a8afda74c5da7d5497888c365c98bd6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421e45a26333e3a27a77435874e7ac0e"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a421e45a26333e3a27a77435874e7ac0e">if_add</a> )(void *priv, enum wpa_driver_if_type type, const char *ifname, const u8 *addr, void *bss_ctx, void **drv_priv, char *force_ifname, u8 *if_addr, const char *bridge, int use_existing, int setup_ap)</td></tr>
<tr class="separator:a421e45a26333e3a27a77435874e7ac0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad276b31419e9984f76dd44a269485cd"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#aad276b31419e9984f76dd44a269485cd">if_remove</a> )(void *priv, enum wpa_driver_if_type type, const char *ifname)</td></tr>
<tr class="separator:aad276b31419e9984f76dd44a269485cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ea30f33fc58b2f2aeb41d44950e94e"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a97ea30f33fc58b2f2aeb41d44950e94e">set_sta_vlan</a> )(void *priv, const u8 *addr, const char *ifname, int vlan_id)</td></tr>
<tr class="separator:a97ea30f33fc58b2f2aeb41d44950e94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cedc58616e4c324228dbefa5739590"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a26cedc58616e4c324228dbefa5739590">commit</a> )(void *priv)</td></tr>
<tr class="separator:a26cedc58616e4c324228dbefa5739590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c026ee9353fd2f9bac05a5cd5695f2e"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a8c026ee9353fd2f9bac05a5cd5695f2e">send_ether</a> )(void *priv, const u8 *dst, const u8 *src, u16 proto, const u8 *data, size_t data_len)</td></tr>
<tr class="separator:a8c026ee9353fd2f9bac05a5cd5695f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f049882e6503d366b15a0f3ee9a841"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a67f049882e6503d366b15a0f3ee9a841">set_radius_acl_auth</a> )(void *priv, const u8 *mac, int accepted, u32 session_timeout)</td></tr>
<tr class="separator:a67f049882e6503d366b15a0f3ee9a841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0152e7898994c4a398bc5f37e17aa2"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a2b0152e7898994c4a398bc5f37e17aa2">set_radius_acl_expire</a> )(void *priv, const u8 *mac)</td></tr>
<tr class="separator:a2b0152e7898994c4a398bc5f37e17aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909209b67c96d91c1d6b634f1ab45786"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a909209b67c96d91c1d6b634f1ab45786">set_ap_wps_ie</a> )(void *priv, const struct <a class="el" href="structwpabuf.html">wpabuf</a> *beacon, const struct <a class="el" href="structwpabuf.html">wpabuf</a> *proberesp, const struct <a class="el" href="structwpabuf.html">wpabuf</a> *assocresp)</td></tr>
<tr class="separator:a909209b67c96d91c1d6b634f1ab45786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83401c2c838161cf9fbdb5415bceb4a"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#ad83401c2c838161cf9fbdb5415bceb4a">set_supp_port</a> )(void *priv, int authorized)</td></tr>
<tr class="separator:ad83401c2c838161cf9fbdb5415bceb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3169a191fd2fced4c113955ca32c5569"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a3169a191fd2fced4c113955ca32c5569">set_wds_sta</a> )(void *priv, const u8 *addr, int aid, int val, const char *bridge_ifname, char *ifname_wds)</td></tr>
<tr class="separator:a3169a191fd2fced4c113955ca32c5569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6fb296d9636933a14c24ae4a2aa602"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a8e6fb296d9636933a14c24ae4a2aa602">send_action</a> )(void *priv, unsigned int <a class="el" href="structfreq.html">freq</a>, unsigned int wait, const u8 *dst, const u8 *src, const u8 *bssid, const u8 *data, size_t data_len, int no_cck)</td></tr>
<tr class="separator:a8e6fb296d9636933a14c24ae4a2aa602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a1ef06c0be3c114c2ad69d98928ce8"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a72a1ef06c0be3c114c2ad69d98928ce8">send_action_cancel_wait</a> )(void *priv)</td></tr>
<tr class="separator:a72a1ef06c0be3c114c2ad69d98928ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cf3039e7b8ea6473793fbbcd7be0a8"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a04cf3039e7b8ea6473793fbbcd7be0a8">remain_on_channel</a> )(void *priv, unsigned int <a class="el" href="structfreq.html">freq</a>, unsigned int duration)</td></tr>
<tr class="separator:a04cf3039e7b8ea6473793fbbcd7be0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5318e501dc32a0fb04bde7a7a9b19a8a"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a5318e501dc32a0fb04bde7a7a9b19a8a">cancel_remain_on_channel</a> )(void *priv)</td></tr>
<tr class="separator:a5318e501dc32a0fb04bde7a7a9b19a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81eb2531b752a54d2fbec3fefd74b514"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a81eb2531b752a54d2fbec3fefd74b514">probe_req_report</a> )(void *priv, int report)</td></tr>
<tr class="separator:a81eb2531b752a54d2fbec3fefd74b514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe71e96f268aad4b9529779ffc9664b5"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#afe71e96f268aad4b9529779ffc9664b5">deinit_ap</a> )(void *priv)</td></tr>
<tr class="separator:afe71e96f268aad4b9529779ffc9664b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14905adb68a6fbf24bd2b585dec02e45"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a14905adb68a6fbf24bd2b585dec02e45">deinit_p2p_cli</a> )(void *priv)</td></tr>
<tr class="separator:a14905adb68a6fbf24bd2b585dec02e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3f72b49ec3feeeb14332db68762f5c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a4e3f72b49ec3feeeb14332db68762f5c">suspend</a> )(void *priv)</td></tr>
<tr class="separator:a4e3f72b49ec3feeeb14332db68762f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66001b81c27f2e3b1f1321b9a6ca872"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#ae66001b81c27f2e3b1f1321b9a6ca872">resume</a> )(void *priv)</td></tr>
<tr class="separator:ae66001b81c27f2e3b1f1321b9a6ca872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdd0f6da5aa64b3f214f613cbc76e6a"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a7cdd0f6da5aa64b3f214f613cbc76e6a">signal_monitor</a> )(void *priv, int threshold, int hysteresis)</td></tr>
<tr class="separator:a7cdd0f6da5aa64b3f214f613cbc76e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620e056cede30098fc42ba4eec5711b8"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a620e056cede30098fc42ba4eec5711b8">send_frame</a> )(void *priv, const u8 *data, size_t data_len, int encrypt)</td></tr>
<tr class="separator:a620e056cede30098fc42ba4eec5711b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e0bbd4194d7eba49ec1c0d007822cb"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#ac4e0bbd4194d7eba49ec1c0d007822cb">get_noa</a> )(void *priv, u8 *buf, size_t buf_len)</td></tr>
<tr class="separator:ac4e0bbd4194d7eba49ec1c0d007822cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72b74bf5f4d588864ad99b65580871f"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#ac72b74bf5f4d588864ad99b65580871f">set_noa</a> )(void *priv, u8 count, int start, int duration)</td></tr>
<tr class="separator:ac72b74bf5f4d588864ad99b65580871f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac75e2f7adc121b3a98e89e058cf148"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a4ac75e2f7adc121b3a98e89e058cf148">set_p2p_powersave</a> )(void *priv, int legacy_ps, int opp_ps, int ctwindow)</td></tr>
<tr class="separator:a4ac75e2f7adc121b3a98e89e058cf148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5909c01db0f30b1223b46dfd86bf613f"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a5909c01db0f30b1223b46dfd86bf613f">ampdu</a> )(void *priv, int ampdu)</td></tr>
<tr class="separator:a5909c01db0f30b1223b46dfd86bf613f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417754bda01b1400ddfda0a63991185c"><td class="memItemLeft" align="right" valign="top">const char *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a417754bda01b1400ddfda0a63991185c">get_radio_name</a> )(void *priv)</td></tr>
<tr class="separator:a417754bda01b1400ddfda0a63991185c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc38009de4111afe59f1c528b486d8a"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#aafc38009de4111afe59f1c528b486d8a">send_tdls_mgmt</a> )(void *priv, const u8 *dst, u8 action_code, u8 dialog_token, u16 status_code, u32 peer_capab, int initiator, const u8 *buf, size_t len)</td></tr>
<tr class="separator:aafc38009de4111afe59f1c528b486d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c72802a9074643f5c16947f7885804a"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a2c72802a9074643f5c16947f7885804a">tdls_oper</a> )(void *priv, enum tdls_oper oper, const u8 *peer)</td></tr>
<tr class="separator:a2c72802a9074643f5c16947f7885804a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec9b90e2f316c2a543b396dca292a48"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a6ec9b90e2f316c2a543b396dca292a48">wnm_oper</a> )(void *priv, enum wnm_oper oper, const u8 *peer, u8 *buf, u16 *buf_len)</td></tr>
<tr class="separator:a6ec9b90e2f316c2a543b396dca292a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7260b85f0cf10b490e11b191580ce63"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#ad7260b85f0cf10b490e11b191580ce63">set_qos_map</a> )(void *priv, const u8 *qos_map_set, u8 qos_map_set_len)</td></tr>
<tr class="separator:ad7260b85f0cf10b490e11b191580ce63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4765a65e4461c741781bb788ecbefe2e"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a4765a65e4461c741781bb788ecbefe2e">br_add_ip_neigh</a> )(void *priv, u8 version, const u8 *ipaddr, int prefixlen, const u8 *addr)</td></tr>
<tr class="separator:a4765a65e4461c741781bb788ecbefe2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbec953bec2aa9f4d8626a9e50c0592"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a2cbec953bec2aa9f4d8626a9e50c0592">br_delete_ip_neigh</a> )(void *priv, u8 version, const u8 *ipaddr)</td></tr>
<tr class="separator:a2cbec953bec2aa9f4d8626a9e50c0592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ec93e47c7a30f21f6b730fd7a16fd5"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#ac6ec93e47c7a30f21f6b730fd7a16fd5">br_port_set_attr</a> )(void *priv, enum drv_br_port_attr attr, unsigned int val)</td></tr>
<tr class="separator:ac6ec93e47c7a30f21f6b730fd7a16fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9706dd26285e48f3973b5d8c8935bda5"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a9706dd26285e48f3973b5d8c8935bda5">br_set_net_param</a> )(void *priv, enum drv_br_net_param param, unsigned int val)</td></tr>
<tr class="separator:a9706dd26285e48f3973b5d8c8935bda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5b780854dbcca5bfb36ed32020ceda"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a7d5b780854dbcca5bfb36ed32020ceda">set_wowlan</a> )(void *priv, const struct <a class="el" href="structwowlan__triggers.html">wowlan_triggers</a> *triggers)</td></tr>
<tr class="separator:a7d5b780854dbcca5bfb36ed32020ceda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28328e27ee31b61aec151a7a2a949172"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a28328e27ee31b61aec151a7a2a949172">signal_poll</a> )(void *priv, struct <a class="el" href="structwpa__signal__info.html">wpa_signal_info</a> *signal_info)</td></tr>
<tr class="separator:a28328e27ee31b61aec151a7a2a949172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99558d6babc80d70a1cb889683d4ae8f"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a99558d6babc80d70a1cb889683d4ae8f">set_authmode</a> )(void *priv, int authmode)</td></tr>
<tr class="separator:a99558d6babc80d70a1cb889683d4ae8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c150b7f5f7e750c5b8fc90aa22b419"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a04c150b7f5f7e750c5b8fc90aa22b419">vendor_cmd</a> )(void *priv, unsigned int vendor_id, unsigned int subcmd, const u8 *data, size_t data_len, struct <a class="el" href="structwpabuf.html">wpabuf</a> *buf)</td></tr>
<tr class="separator:a04c150b7f5f7e750c5b8fc90aa22b419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2960f7a5677e6c44247bd1a52d4fb897"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a2960f7a5677e6c44247bd1a52d4fb897">set_rekey_info</a> )(void *priv, const u8 *kek, size_t kek_len, const u8 *kck, size_t kck_len, const u8 *replay_ctr)</td></tr>
<tr class="separator:a2960f7a5677e6c44247bd1a52d4fb897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ef949e8c95577db9e8a9a0c0ee26bf"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a41ef949e8c95577db9e8a9a0c0ee26bf">sta_assoc</a> )(void *priv, const u8 *own_addr, const u8 *addr, int reassoc, u16 <a class="el" href="structwpa__driver__ops.html#a19641636b640f7b776ebbc9e86bbbe66">status</a>, const u8 *ie, size_t len)</td></tr>
<tr class="separator:a41ef949e8c95577db9e8a9a0c0ee26bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dc682e1edcd54530847f555e2594b3"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a98dc682e1edcd54530847f555e2594b3">sta_auth</a> )(void *priv, const u8 *own_addr, const u8 *addr, u16 seq, u16 <a class="el" href="structwpa__driver__ops.html#a19641636b640f7b776ebbc9e86bbbe66">status</a>, const u8 *ie, size_t len)</td></tr>
<tr class="separator:a98dc682e1edcd54530847f555e2594b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99446f03f0840a68aafe5c77cbb01e1e"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a99446f03f0840a68aafe5c77cbb01e1e">add_tspec</a> )(void *priv, const u8 *addr, u8 *tspec_ie, size_t tspec_ielen)</td></tr>
<tr class="separator:a99446f03f0840a68aafe5c77cbb01e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41b47d91830a15a0c74b0b0e20b5787"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#ac41b47d91830a15a0c74b0b0e20b5787">add_sta_node</a> )(void *priv, const u8 *addr, u16 auth_alg)</td></tr>
<tr class="separator:ac41b47d91830a15a0c74b0b0e20b5787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b955c967dde49f7ca40c779ed1bfd2"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#ab8b955c967dde49f7ca40c779ed1bfd2">sched_scan</a> )(void *priv, struct <a class="el" href="structwpa__driver__scan__params.html">wpa_driver_scan_params</a> *params)</td></tr>
<tr class="separator:ab8b955c967dde49f7ca40c779ed1bfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b60e49d569f230dc6499bb5a4ab409"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a85b60e49d569f230dc6499bb5a4ab409">stop_sched_scan</a> )(void *priv)</td></tr>
<tr class="separator:a85b60e49d569f230dc6499bb5a4ab409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6ef4c7848e78dee3838afaba9a58f5"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a1c6ef4c7848e78dee3838afaba9a58f5">poll_client</a> )(void *priv, const u8 *own_addr, const u8 *addr, int qos)</td></tr>
<tr class="separator:a1c6ef4c7848e78dee3838afaba9a58f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dfa05f992ff0180ca3435b14a7a898"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a25dfa05f992ff0180ca3435b14a7a898">radio_disable</a> )(void *priv, int disabled)</td></tr>
<tr class="separator:a25dfa05f992ff0180ca3435b14a7a898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369c25de648f7743032657f29c62cb6b"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a369c25de648f7743032657f29c62cb6b">switch_channel</a> )(void *priv, struct <a class="el" href="structcsa__settings.html">csa_settings</a> *settings)</td></tr>
<tr class="separator:a369c25de648f7743032657f29c62cb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57a1fa425c6f1c46fc8484d3856adbf"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#ae57a1fa425c6f1c46fc8484d3856adbf">add_tx_ts</a> )(void *priv, u8 tsid, const u8 *addr, u8 user_prio, u16 admitted_time)</td></tr>
<tr class="separator:ae57a1fa425c6f1c46fc8484d3856adbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389f193887d93fbcc3fe597a1ca05739"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a389f193887d93fbcc3fe597a1ca05739">del_tx_ts</a> )(void *priv, u8 tsid, const u8 *addr)</td></tr>
<tr class="separator:a389f193887d93fbcc3fe597a1ca05739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e4e9d413656b73d88d12e0471d34f9"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a42e4e9d413656b73d88d12e0471d34f9">tdls_enable_channel_switch</a> )(void *priv, const u8 *addr, u8 oper_class, const struct <a class="el" href="structhostapd__freq__params.html">hostapd_freq_params</a> *params)</td></tr>
<tr class="separator:a42e4e9d413656b73d88d12e0471d34f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac8c9398b2236a27c4494fa8d58209b"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a9ac8c9398b2236a27c4494fa8d58209b">tdls_disable_channel_switch</a> )(void *priv, const u8 *addr)</td></tr>
<tr class="separator:a9ac8c9398b2236a27c4494fa8d58209b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33da6323af8d710ab778f8e68689d737"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a33da6323af8d710ab778f8e68689d737">start_dfs_cac</a> )(void *priv, struct <a class="el" href="structhostapd__freq__params.html">hostapd_freq_params</a> *<a class="el" href="structfreq.html">freq</a>)</td></tr>
<tr class="separator:a33da6323af8d710ab778f8e68689d737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8445cefc2710817ea37996e6fb95e9c5"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a8445cefc2710817ea37996e6fb95e9c5">stop_ap</a> )(void *priv)</td></tr>
<tr class="separator:a8445cefc2710817ea37996e6fb95e9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d7adb4b46e02d4baa6b20f29d2fc4d"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a75d7adb4b46e02d4baa6b20f29d2fc4d">get_survey</a> )(void *priv, unsigned int <a class="el" href="structfreq.html">freq</a>)</td></tr>
<tr class="separator:a75d7adb4b46e02d4baa6b20f29d2fc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19641636b640f7b776ebbc9e86bbbe66"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a19641636b640f7b776ebbc9e86bbbe66">status</a> )(void *priv, char *buf, size_t buflen)</td></tr>
<tr class="separator:a19641636b640f7b776ebbc9e86bbbe66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307154101021ae2dc8eaf58e12e7828e"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a307154101021ae2dc8eaf58e12e7828e">roaming</a> )(void *priv, int allowed, const u8 *bssid)</td></tr>
<tr class="separator:a307154101021ae2dc8eaf58e12e7828e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab507297b8ccce4b498f77c4875a4f53d"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#ab507297b8ccce4b498f77c4875a4f53d">set_mac_addr</a> )(void *priv, const u8 *addr)</td></tr>
<tr class="separator:ab507297b8ccce4b498f77c4875a4f53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b3160d8d6f76f9ea01ac39e82aa9b6"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a47b3160d8d6f76f9ea01ac39e82aa9b6">init_mesh</a> )(void *priv)</td></tr>
<tr class="separator:a47b3160d8d6f76f9ea01ac39e82aa9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad413bb18cd2268b733d177258d039d16"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#ad413bb18cd2268b733d177258d039d16">join_mesh</a> )(void *priv, struct <a class="el" href="structwpa__driver__mesh__join__params.html">wpa_driver_mesh_join_params</a> *params)</td></tr>
<tr class="separator:ad413bb18cd2268b733d177258d039d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dab14ec8478f2686152cf06c30a5fa0"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a7dab14ec8478f2686152cf06c30a5fa0">leave_mesh</a> )(void *priv)</td></tr>
<tr class="separator:a7dab14ec8478f2686152cf06c30a5fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3a19a5e03e855bcb13cde9a485481b"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a8f3a19a5e03e855bcb13cde9a485481b">do_acs</a> )(void *priv, struct <a class="el" href="structdrv__acs__params.html">drv_acs_params</a> *params)</td></tr>
<tr class="separator:a8f3a19a5e03e855bcb13cde9a485481b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47442c1d785b0dc51a406f9921f7b4b"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#ae47442c1d785b0dc51a406f9921f7b4b">set_band</a> )(void *priv, enum set_band <a class="el" href="structband.html">band</a>)</td></tr>
<tr class="separator:ae47442c1d785b0dc51a406f9921f7b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8beee751a9979e18623f797cf21b4c36"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a8beee751a9979e18623f797cf21b4c36">get_pref_freq_list</a> )(void *priv, enum wpa_driver_if_type if_type, unsigned int *num, unsigned int *freq_list)</td></tr>
<tr class="separator:a8beee751a9979e18623f797cf21b4c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9f4b56abe1d2bdf4845a4e54d42a91"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#abf9f4b56abe1d2bdf4845a4e54d42a91">set_prob_oper_freq</a> )(void *priv, unsigned int <a class="el" href="structfreq.html">freq</a>)</td></tr>
<tr class="separator:abf9f4b56abe1d2bdf4845a4e54d42a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae8a454bcb3bfe702556be224404ee1"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a0ae8a454bcb3bfe702556be224404ee1">abort_scan</a> )(void *priv)</td></tr>
<tr class="separator:a0ae8a454bcb3bfe702556be224404ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbea260765501e1cebbc415805c3b64"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a1cbea260765501e1cebbc415805c3b64">configure_data_frame_filters</a> )(void *priv, u32 filter_flags)</td></tr>
<tr class="separator:a1cbea260765501e1cebbc415805c3b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0480336276872fd3de92f9619c86e0a7"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a0480336276872fd3de92f9619c86e0a7">get_ext_capab</a> )(void *priv, enum wpa_driver_if_type type, const u8 **ext_capab, const u8 **ext_capab_mask, unsigned int *ext_capab_len)</td></tr>
<tr class="separator:a0480336276872fd3de92f9619c86e0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cebea2b7b5fc3db9fc709c1b738d5df"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a7cebea2b7b5fc3db9fc709c1b738d5df">p2p_lo_start</a> )(void *priv, unsigned int <a class="el" href="structfreq.html">freq</a>, unsigned int period, unsigned int interval, unsigned int count, const u8 *device_types, size_t dev_types_len, const u8 *ies, size_t ies_len)</td></tr>
<tr class="separator:a7cebea2b7b5fc3db9fc709c1b738d5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060b2746682d32aaaa04bd39f84fdc0f"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a060b2746682d32aaaa04bd39f84fdc0f">p2p_lo_stop</a> )(void *priv)</td></tr>
<tr class="separator:a060b2746682d32aaaa04bd39f84fdc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06535bc5f8e20b5bc5041fbe6d7dd51e"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpa__driver__ops.html#a06535bc5f8e20b5bc5041fbe6d7dd51e">set_default_scan_ies</a> )(void *priv, const u8 *ies, size_t ies_len)</td></tr>
<tr class="separator:a06535bc5f8e20b5bc5041fbe6d7dd51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>struct <a class="el" href="structwpa__driver__ops.html">wpa_driver_ops</a> - Driver interface API definition</p>
<p>This structure defines the API that each driver interface needs to implement for core wpa_supplicant code. All driver specific functionality is captured in this wrapper. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a0ae8a454bcb3bfe702556be224404ee1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::abort_scan)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>abort_scan - Request the driver to abort an ongoing scan : Private driver interface data Returns 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a593e2b92abdd987eeb27c03e6a830137"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::add_pmkid)(void *priv, const u8 *bssid, const u8 *pmkid)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>add_pmkid - Add PMKSA cache entry to the driver : private driver interface data : BSSID for the PMKSA cache entry : PMKID for the PMKSA cache entry</p>
<p>Returns: 0 on success, -1 on failure</p>
<p>This function is called when a new PMK is received, as a result of either normal authentication or RSN pre-authentication.</p>
<p>If the driver generates RSN IE, i.e., it does not use wpa_ie in <a class="el" href="structwpa__driver__ops.html#aab2985f9322b4e24f53508a164479d62">associate()</a>, <a class="el" href="structwpa__driver__ops.html#a593e2b92abdd987eeb27c03e6a830137">add_pmkid()</a> can be used to add new PMKSA cache entries in the driver. If the driver uses wpa_ie from wpa_supplicant, this driver_ops function does not need to be implemented. Likewise, if the driver does not support WPA, this function is not needed. </p>

</div>
</div>
<a class="anchor" id="ac41b47d91830a15a0c74b0b0e20b5787"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::add_sta_node)(void *priv, const u8 *addr, u16 auth_alg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>add_sta_node - Add a station node in the driver : Private driver interface data : MAC address of the station to add : authentication algorithm used by the station Returns: 0 on success, -1 on failure</p>
<p>This function adds the station node in the driver, when the station gets added by FT-over-DS. </p>

</div>
</div>
<a class="anchor" id="a99446f03f0840a68aafe5c77cbb01e1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::add_tspec)(void *priv, const u8 *addr, u8 *tspec_ie, size_t tspec_ielen)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>add_tspec - Add traffic stream : Private driver interface data : MAC address of the station to associate : tspec ie buffer : tspec ie length Returns: 0 on success, -1 on failure</p>
<p>This function adds the traffic steam for the station and fills the medium_time in tspec_ie. </p>

</div>
</div>
<a class="anchor" id="ae57a1fa425c6f1c46fc8484d3856adbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::add_tx_ts)(void *priv, u8 tsid, const u8 *addr, u8 user_prio, u16 admitted_time)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>add_tx_ts - Add traffic stream : Private driver interface data : Traffic stream ID : Receiver address : User priority of the traffic stream : Admitted time for this TS in units of 32 microsecond periods (per second). Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a5909c01db0f30b1223b46dfd86bf613f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::ampdu)(void *priv, int ampdu)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ampdu - Enable/disable aggregation : Private driver interface data : 1/0 = enable/disable A-MPDU aggregation Returns: 0 on success or -1 on failure </p>

</div>
</div>
<a class="anchor" id="aab2985f9322b4e24f53508a164479d62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::associate)(void *priv, struct <a class="el" href="structwpa__driver__associate__params.html">wpa_driver_associate_params</a> *params)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>associate - Request driver to associate : private driver interface data : association parameters</p>
<p>Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a5f3679419d9276dace431505a93647db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::authenticate)(void *priv, struct <a class="el" href="structwpa__driver__auth__params.html">wpa_driver_auth_params</a> *params)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>authenticate - Request driver to authenticate : private driver interface data : authentication parameters Returns: 0 on success, -1 on failure</p>
<p>This is an optional function that can be used with drivers that support separate authentication and association steps, i.e., when wpa_supplicant can act as the SME. If not implemented, <a class="el" href="structwpa__driver__ops.html#aab2985f9322b4e24f53508a164479d62">associate()</a> function is expected to take care of IEEE 802.11 authentication, too. </p>

</div>
</div>
<a class="anchor" id="a4765a65e4461c741781bb788ecbefe2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::br_add_ip_neigh)(void *priv, u8 version, const u8 *ipaddr, int prefixlen, const u8 *addr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>br_add_ip_neigh - Add a neigh to the bridge ip neigh table : Private driver interface data </p>
<dl class="section version"><dt>Version</dt><dd>: IP version of the IP address, 4 or 6 : IP address for the neigh entry : IP address prefix length : Corresponding MAC address Returns: 0 on success, negative (&lt;0) on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a2cbec953bec2aa9f4d8626a9e50c0592"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::br_delete_ip_neigh)(void *priv, u8 version, const u8 *ipaddr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>br_delete_ip_neigh - Remove a neigh from the bridge ip neigh table : Private driver interface data </p>
<dl class="section version"><dt>Version</dt><dd>: IP version of the IP address, 4 or 6 : IP address for the neigh entry Returns: 0 on success, negative (&lt;0) on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ac6ec93e47c7a30f21f6b730fd7a16fd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::br_port_set_attr)(void *priv, enum drv_br_port_attr attr, unsigned int val)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>br_port_set_attr - Set a bridge port attribute : Bridge port attribute to set : Value to be set Returns: 0 on success, negative (&lt;0) on failure </p>

</div>
</div>
<a class="anchor" id="a9706dd26285e48f3973b5d8c8935bda5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::br_set_net_param)(void *priv, enum drv_br_net_param param, unsigned int val)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>br_port_set_attr - Set a bridge network parameter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td>Bridge parameter to set : Value to be set Returns: 0 on success, negative (&lt;0) on failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5318e501dc32a0fb04bde7a7a9b19a8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::cancel_remain_on_channel)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>cancel_remain_on_channel - Cancel remain-on-channel operation : Private driver interface data</p>
<p>This command can be used to cancel a remain-on-channel operation before its originally requested duration has passed. This could be used, e.g., when <a class="el" href="structwpa__driver__ops.html#a04cf3039e7b8ea6473793fbbcd7be0a8">remain_on_channel()</a> is used to request extra time to receive a response to an Action frame and the response is received when there is still unneeded time remaining on the remain-on-channel operation. </p>

</div>
</div>
<a class="anchor" id="a26cedc58616e4c324228dbefa5739590"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::commit)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>commit - Optional commit changes handler (AP only) : driver private data Returns: 0 on success, -1 on failure</p>
<p>This optional handler function can be registered if the driver interface implementation needs to commit changes (e.g., by setting network interface up) at the end of initial configuration. If set, this handler will be called after initial setup has been completed. </p>

</div>
</div>
<a class="anchor" id="a1cbea260765501e1cebbc415805c3b64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::configure_data_frame_filters)(void *priv, u32 filter_flags)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>configure_data_frame_filters - Request to configure frame filters : Private driver interface data : The type of frames to filter (bitfield of WPA_DATA_FRAME_FILTER_FLAG_*) Returns: 0 on success or -1 on failure </p>

</div>
</div>
<a class="anchor" id="a6447201e96d72b23d2e7b0c5d1d86c6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::deauthenticate)(void *priv, const u8 *addr, int reason_code)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>deauthenticate - Request driver to deauthenticate : private driver interface data : peer address (BSSID of the AP) : 16-bit reason code to be sent in the deauthentication frame</p>
<p>Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a80c9a92dc2061694c7b9baa8423b5f8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* wpa_driver_ops::deinit)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>deinit - Deinitialize driver interface : private driver interface data from <a class="el" href="structwpa__driver__ops.html#a247e66445054de570b291854b1b4de2d">init()</a></p>
<p>Shut down driver interface and processing of driver events. Free private data buffer if one was allocated in <a class="el" href="structwpa__driver__ops.html#a247e66445054de570b291854b1b4de2d">init()</a> handler. </p>

</div>
</div>
<a class="anchor" id="afe71e96f268aad4b9529779ffc9664b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::deinit_ap)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>deinit_ap - Deinitialize AP mode : Private driver interface data Returns: 0 on success, -1 on failure (or if not supported)</p>
<p>This optional function can be used to disable AP mode related configuration. If the interface was not dynamically added, change the driver mode to station mode to allow normal station operations like scanning to be completed. </p>

</div>
</div>
<a class="anchor" id="a14905adb68a6fbf24bd2b585dec02e45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::deinit_p2p_cli)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>deinit_p2p_cli - Deinitialize P2P client mode : Private driver interface data Returns: 0 on success, -1 on failure (or if not supported)</p>
<p>This optional function can be used to disable P2P client mode. If the interface was not dynamically added, change the interface type back to station mode. </p>

</div>
</div>
<a class="anchor" id="a389f193887d93fbcc3fe597a1ca05739"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::del_tx_ts)(void *priv, u8 tsid, const u8 *addr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>del_tx_ts - Delete traffic stream : Private driver interface data : Traffic stream ID : Receiver address Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a12b9089a419658b8f958097b676e4832"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* wpa_driver_ops::desc</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>One line description of the driver interface </p>

</div>
</div>
<a class="anchor" id="a8f3a19a5e03e855bcb13cde9a485481b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::do_acs)(void *priv, struct <a class="el" href="structdrv__acs__params.html">drv_acs_params</a> *params)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>do_acs - Automatically select channel : Private driver interface data : Parameters for ACS Returns 0 on success, -1 on failure</p>
<p>This command can be used to offload ACS to the driver if the driver indicates support for such offloading (WPA_DRIVER_FLAGS_ACS_OFFLOAD). </p>

</div>
</div>
<a class="anchor" id="a6ad82e7ac6e660ed0db8abb18f89eb29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::flush)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>flush - Flush all association stations (AP only) : Private driver interface data Returns: 0 on success, -1 on failure</p>
<p>This function requests the driver to disassociate all associated stations. This function does not need to be implemented if the driver does not process association frames internally. </p>

</div>
</div>
<a class="anchor" id="a7ea95b5c762f95b0dd1d3870753278a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::flush_pmkid)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>flush_pmkid - Flush PMKSA cache : private driver interface data</p>
<p>Returns: 0 on success, -1 on failure</p>
<p>This function is called when the supplicant drops all PMKSA cache entries for any reason.</p>
<p>If the driver generates RSN IE, i.e., it does not use wpa_ie in <a class="el" href="structwpa__driver__ops.html#aab2985f9322b4e24f53508a164479d62">associate()</a>, <a class="el" href="structwpa__driver__ops.html#a5101fd0e80c8343439c6741facb9f7d6">remove_pmkid()</a> can be used to synchronize PMKSA caches between the driver and wpa_supplicant. If the driver uses wpa_ie from wpa_supplicant, this driver_ops function does not need to be implemented. Likewise, if the driver does not support WPA, this function is not needed. </p>

</div>
</div>
<a class="anchor" id="abcb69d901da34f5810ffe76b0d6a01b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::get_bssid)(void *priv, u8 *bssid)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get_bssid - Get the current BSSID : private driver interface data : buffer for BSSID (ETH_ALEN = 6 bytes)</p>
<p>Returns: 0 on success, -1 on failure</p>
<p>Query kernel driver for the current BSSID and copy it to bssid. Setting bssid to 00:00:00:00:00:00 is recommended if the STA is not associated. </p>

</div>
</div>
<a class="anchor" id="a4d87ddf442ba6643db82bbb7eded00fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::get_capa)(void *priv, struct <a class="el" href="structwpa__driver__capa.html">wpa_driver_capa</a> *capa)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get_capa - Get driver capabilities : private driver interface data</p>
<p>Returns: 0 on success, -1 on failure</p>
<p>Get driver/firmware/hardware capabilities. </p>

</div>
</div>
<a class="anchor" id="a62682a2eae7dd228fa12cd536adcdbd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::get_country)(void *priv, char *alpha2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get_country - Get country : Private driver interface data : Buffer for returning country code (at least 3 octets) Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a0480336276872fd3de92f9619c86e0a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::get_ext_capab)(void *priv, enum wpa_driver_if_type type, const u8 **ext_capab, const u8 **ext_capab_mask, unsigned int *ext_capab_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get_ext_capab - Get extended capabilities for the specified interface : Private driver interface data : Interface type for which to get extended capabilities : Extended capabilities fetched : Extended capabilities mask : Length of the extended capabilities Returns: 0 on success or -1 on failure </p>

</div>
</div>
<a class="anchor" id="a99845a556a35e4cd53b58f13ad0154c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structhostapd__hw__modes.html">hostapd_hw_modes</a>*(* wpa_driver_ops::get_hw_feature_data)(void *priv, u16 *num_modes, u16 *flags)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get_hw_feature_data - Get hardware support data (channels and rates) : Private driver interface data : Variable for returning the number of returned modes flags: Variable for returning hardware feature flags Returns: Pointer to allocated hardware data on success or NULL on failure. Caller is responsible for freeing this. </p>

</div>
</div>
<a class="anchor" id="a32b727bb678254f2a5d907528ccad677"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int(* wpa_driver_ops::get_ifindex)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get_ifindex - Get interface index : private driver interface data</p>
<p>Returns: Interface index </p>

</div>
</div>
<a class="anchor" id="a09913aed5ecc094f48120a152303311e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char*(* wpa_driver_ops::get_ifname)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get_ifname - Get interface name : private driver interface data</p>
<p>Returns: Pointer to the interface name. This can differ from the interface name used in <a class="el" href="structwpa__driver__ops.html#a247e66445054de570b291854b1b4de2d">init()</a> call. Init() is called first.</p>
<p>This optional function can be used to allow the driver interface to replace the interface name with something else, e.g., based on an interface mapping from a more descriptive name. </p>

</div>
</div>
<a class="anchor" id="af7ab96d480d1908fc8371269e4edc1e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::get_inact_sec)(void *priv, const u8 *addr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get_inact_sec - Get station inactivity duration (AP only) : Private driver interface data : Station address Returns: Number of seconds station has been inactive, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a30b47e7dbef5d8830421893fc17995db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwpa__interface__info.html">wpa_interface_info</a>*(* wpa_driver_ops::get_interfaces)(void *global_priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get_interfaces - Get information about available interfaces : private driver global data from <a class="el" href="structwpa__driver__ops.html#a603c9fc1c7ce20dce68d6f377782c446">global_init()</a> Returns: Allocated buffer of interface information (caller is responsible for freeing the data structure) on success, NULL on failure </p>

</div>
</div>
<a class="anchor" id="ab410829ac706da13b57cbf63c0368895"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const u8*(* wpa_driver_ops::get_mac_addr)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get_mac_addr - Get own MAC address : private driver interface data</p>
<p>Returns: Pointer to own MAC address or NULL on failure</p>
<p>This optional function can be used to get the own MAC address of the device from the driver interface code. This is only needed if the l2_packet implementation for the OS does not provide easy access to a MAC address. </p>

</div>
</div>
<a class="anchor" id="ac4e0bbd4194d7eba49ec1c0d007822cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::get_noa)(void *priv, u8 *buf, size_t buf_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get_noa - Get current Notice of Absence attribute payload : Private driver interface data : Buffer for returning NoA : Buffer length in octets Returns: Number of octets used in buf, 0 to indicate no NoA is being advertized, or -1 on failure</p>
<p>This function is used to fetch the current Notice of Absence attribute value from GO. </p>

</div>
</div>
<a class="anchor" id="a8beee751a9979e18623f797cf21b4c36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::get_pref_freq_list)(void *priv, enum wpa_driver_if_type if_type, unsigned int *num, unsigned int *freq_list)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get_pref_freq_list - Get preferred frequency list for an interface : Private driver interface data : Interface type : Number of channels : Preferred channel frequency list encoded in MHz values Returns 0 on success, -1 on failure</p>
<p>This command can be used to query the preferred frequency list from the driver specific to a particular interface type. </p>

</div>
</div>
<a class="anchor" id="a417754bda01b1400ddfda0a63991185c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char*(* wpa_driver_ops::get_radio_name)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get_radio_name - Get physical radio name for the device : Private driver interface data Returns: Radio name or NULL if not known</p>
<p>The returned data must not be modified by the caller. It is assumed that any interface that has the same radio name as another is sharing the same physical radio. This information can be used to share scan results etc. information between the virtual interfaces to speed up various operations. </p>

</div>
</div>
<a class="anchor" id="a058e8d7899cc93a6ebd97a58f4499d3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwpa__scan__results.html">wpa_scan_results</a>*(* wpa_driver_ops::get_scan_results2)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get_scan_results2 - Fetch the latest scan results : private driver interface data</p>
<p>Returns: Allocated buffer of scan results (caller is responsible for freeing the data structure) on success, NULL on failure </p>

</div>
</div>
<a class="anchor" id="ab95c6ff890ea90e68239bc94cf87c140"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::get_seqnum)(const char *ifname, void *priv, const u8 *addr, int idx, u8 *seq)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get_seqnum - Fetch the current TSC/packet number (AP only) : The interface name (main or virtual) : Private driver interface data : MAC address of the station or NULL for group keys : Key index : Buffer for returning the latest used TSC/packet number Returns: 0 on success, -1 on failure</p>
<p>This function is used to fetch the last used TSC/packet number for a TKIP, CCMP, GCMP, or BIP/IGTK key. It is mainly used with group keys, so there is no strict requirement on implementing support for unicast keys (i.e., addr != NULL). </p>

</div>
</div>
<a class="anchor" id="ae55c366c5799ee641689724967b7de15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::get_ssid)(void *priv, u8 *ssid)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get_ssid - Get the current SSID : private driver interface data : buffer for SSID (at least 32 bytes)</p>
<p>Returns: Length of the SSID on success, -1 on failure</p>
<p>Query kernel driver for the current SSID and copy it to ssid. Returning zero is recommended if the STA is not associated.</p>
<p>Note: SSID is an array of octets, i.e., it is not nul terminated and can, at least in theory, contain control characters (including nul) and as such, should be processed as binary data, not a printable string. </p>

</div>
</div>
<a class="anchor" id="a75d7adb4b46e02d4baa6b20f29d2fc4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::get_survey)(void *priv, unsigned int <a class="el" href="structfreq.html">freq</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get_survey - Retrieve survey data : Private driver interface data : If set, survey data for the specified frequency is only being requested. If not set, all survey data is requested. Returns: 0 on success, -1 on failure</p>
<p>Use this to retrieve:</p>
<ul>
<li>the observed channel noise floor</li>
<li>the amount of time we have spent on the channel</li>
<li>the amount of time during which we have spent on the channel that the radio has determined the medium is busy and we cannot transmit</li>
<li>the amount of time we have spent receiving data</li>
<li>the amount of time we have spent transmitting data</li>
</ul>
<p>This data can be used for spectrum heuristics. One example is Automatic Channel Selection (ACS). The channel survey data is kept on a linked list on the channel data, one entry is added for each survey. The min_nf of the channel is updated for each survey. </p>

</div>
</div>
<a class="anchor" id="aef740f80e92476d296dbc51b336cbfa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* wpa_driver_ops::global_deinit)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>global_deinit - Global driver deinitialization : private driver global data from <a class="el" href="structwpa__driver__ops.html#a603c9fc1c7ce20dce68d6f377782c446">global_init()</a></p>
<p>Terminate any global driver related functionality and free the global data structure. </p>

</div>
</div>
<a class="anchor" id="a603c9fc1c7ce20dce68d6f377782c446"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* wpa_driver_ops::global_init)(void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>global_init - Global driver initialization : wpa_global pointer Returns: Pointer to private data (global), NULL on failure</p>
<p>This optional function is called to initialize the driver wrapper for global data, i.e., data that applies to all interfaces. If this function is implemented, <a class="el" href="structwpa__driver__ops.html#aef740f80e92476d296dbc51b336cbfa7">global_deinit()</a> will also need to be implemented to free the private data. The driver will also likely use <a class="el" href="structwpa__driver__ops.html#a7ce383ea8244702f503f4fbdd7402011">init2()</a> function instead of <a class="el" href="structwpa__driver__ops.html#a247e66445054de570b291854b1b4de2d">init()</a> to get the pointer to global data available to per-interface initializer. </p>

</div>
</div>
<a class="anchor" id="a7881f78182d904efa2f2ec514441fce0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* wpa_driver_ops::hapd_deinit)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>hapd_deinit - Deinitialize driver interface (hostapd only) : Private driver interface data from <a class="el" href="structwpa__driver__ops.html#aa031fa85b113d12a6a2ee27b456fa444">hapd_init()</a> </p>

</div>
</div>
<a class="anchor" id="a384c895e21715325244ba3471b715a4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::hapd_get_ssid)(void *priv, u8 *buf, int len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>hapd_get_ssid - Get the current SSID (AP only) : Private driver interface data : Buffer for returning the SSID : Maximum length of the buffer Returns: Length of the SSID on success, -1 on failure</p>
<p>This function need not be implemented if the driver uses Beacon template from <a class="el" href="structwpa__driver__ops.html#a565bd07356ac6f552a692cfd72b448ec">set_ap()</a> and does not reply to Probe Request frames. </p>

</div>
</div>
<a class="anchor" id="aa031fa85b113d12a6a2ee27b456fa444"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* wpa_driver_ops::hapd_init)(struct <a class="el" href="structhostapd__data.html">hostapd_data</a> *hapd, struct <a class="el" href="structwpa__init__params.html">wpa_init_params</a> *params)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>hapd_init - Initialize driver interface (hostapd only) : Pointer to hostapd context : Configuration for the driver wrapper Returns: Pointer to private data, NULL on failure</p>
<p>This function is used instead of <a class="el" href="structwpa__driver__ops.html#a247e66445054de570b291854b1b4de2d">init()</a> or <a class="el" href="structwpa__driver__ops.html#a7ce383ea8244702f503f4fbdd7402011">init2()</a> when the driver wrapper is used with hostapd. </p>

</div>
</div>
<a class="anchor" id="a5d10bb9b3c7049f2a36cd95a158f2ee6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::hapd_send_eapol)(void *priv, const u8 *addr, const u8 *data, size_t data_len, int encrypt, const u8 *own_addr, u32 flags)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>hapd_send_eapol - Send an EAPOL packet (AP only) : private driver interface data : Destination MAC address : EAPOL packet starting with IEEE 802.1X header : Length of the EAPOL packet in octets : Whether the frame should be encrypted : Source MAC address : WPA_STA_* flags for the destination station</p>
<p>Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a200de14c5ce1da387dfbb7b6354d2b13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::hapd_set_countermeasures)(void *priv, int enabled)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>hapd_set_countermeasures - Enable/disable TKIP countermeasures (AP) : Private driver interface data : 1 = countermeasures enabled, 0 = disabled Returns: 0 on success, -1 on failure</p>
<p>This need not be implemented if the driver does not take care of association processing. </p>

</div>
</div>
<a class="anchor" id="a5d13d02abfc6b19fd0b9f01bcb2db76f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::hapd_set_ssid)(void *priv, const u8 *buf, int len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>hapd_set_ssid - Set SSID (AP only) : Private driver interface data : SSID : Length of the SSID in octets Returns: 0 on success, -1 on failure</p>
<p>DEPRECATED - use <a class="el" href="structwpa__driver__ops.html#a565bd07356ac6f552a692cfd72b448ec">set_ap()</a> instead </p>

</div>
</div>
<a class="anchor" id="a421e45a26333e3a27a77435874e7ac0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::if_add)(void *priv, enum wpa_driver_if_type type, const char *ifname, const u8 *addr, void *bss_ctx, void **drv_priv, char *force_ifname, u8 *if_addr, const char *bridge, int use_existing, int setup_ap)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>if_add - Add a virtual interface : Private driver interface data : Interface type : Interface name for the new virtual interface : Local address to use for the interface or NULL to use the parent interface address : BSS context for WPA_IF_AP_BSS interfaces : Pointer for overwriting the driver context or NULL if not allowed (applies only to WPA_IF_AP_BSS type) : Buffer for returning an interface name that the driver ended up using if it differs from the requested ifname : Buffer for returning the allocated interface address (this may differ from the requested addr if the driver cannot change interface address) : Bridge interface to use or NULL if no bridge configured : Whether to allow existing interface to be used : Whether to setup AP for WPA_IF_AP_BSS interfaces Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="aad276b31419e9984f76dd44a269485cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::if_remove)(void *priv, enum wpa_driver_if_type type, const char *ifname)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>if_remove - Remove a virtual interface : Private driver interface data : Interface type : Interface name of the virtual interface to be removed Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a247e66445054de570b291854b1b4de2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* wpa_driver_ops::init)(void *ctx, const char *ifname)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>init - Initialize driver interface : context to be used when calling wpa_supplicant functions, e.g., wpa_supplicant_event() : interface name, e.g., wlan0</p>
<p>Returns: Pointer to private data, NULL on failure</p>
<p>Initialize driver interface, including event processing for kernel driver events (e.g., associated, scan results, Michael MIC failure). This function can allocate a private configuration data area for , file descriptor, interface name, etc. information that may be needed in future driver operations. If this is not used, non-NULL value will need to be returned because NULL is used to indicate failure. The returned value will be used as 'void *priv' data for all other driver_ops functions.</p>
<p>The main event loop (eloop.c) of wpa_supplicant can be used to register callback for read sockets (eloop_register_read_sock()).</p>
<p>See below for more information about events and wpa_supplicant_event() function. </p>

</div>
</div>
<a class="anchor" id="a7ce383ea8244702f503f4fbdd7402011"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* wpa_driver_ops::init2)(void *ctx, const char *ifname, void *global_priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>init2 - Initialize driver interface (with global data) : context to be used when calling wpa_supplicant functions, e.g., wpa_supplicant_event() : interface name, e.g., wlan0 : private driver global data from <a class="el" href="structwpa__driver__ops.html#a603c9fc1c7ce20dce68d6f377782c446">global_init()</a> Returns: Pointer to private data, NULL on failure</p>
<p>This function can be used instead of <a class="el" href="structwpa__driver__ops.html#a247e66445054de570b291854b1b4de2d">init()</a> if the driver wrapper uses global data. </p>

</div>
</div>
<a class="anchor" id="a47b3160d8d6f76f9ea01ac39e82aa9b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::init_mesh)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>init_mesh - Driver specific initialization for mesh : Private driver interface data Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="ad413bb18cd2268b733d177258d039d16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::join_mesh)(void *priv, struct <a class="el" href="structwpa__driver__mesh__join__params.html">wpa_driver_mesh_join_params</a> *params)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>join_mesh - Join a mesh network : Private driver interface data : Mesh configuration parameters Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a7dab14ec8478f2686152cf06c30a5fa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::leave_mesh)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>leave_mesh - Leave a mesh network : Private driver interface data Returns 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a94994ed8eac24845ee5be54320e7d2a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::mlme_setprotection)(void *priv, const u8 *addr, int protect_type, int key_type)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mlme_setprotection - MLME-SETPROTECTION.request primitive : Private driver interface data : Address of the station for which to set protection (may be NULL for group keys) : MLME_SETPROTECTION_PROTECT_TYPE_* : MLME_SETPROTECTION_KEY_TYPE_* Returns: 0 on success, -1 on failure</p>
<p>This is an optional function that can be used to set the driver to require protection for Tx and/or Rx frames. This uses the layer interface defined in IEEE 802.11i-2004 clause 10.3.22.1 (MLME-SETPROTECTION.request). Many drivers do not use explicit set protection operation; instead, they set protection implicitly based on configured keys. </p>

</div>
</div>
<a class="anchor" id="a91ef3e58a1174b2a412e4d50ce1dea63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* wpa_driver_ops::name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Name of the driver interface </p>

</div>
</div>
<a class="anchor" id="a7cebea2b7b5fc3db9fc709c1b738d5df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::p2p_lo_start)(void *priv, unsigned int <a class="el" href="structfreq.html">freq</a>, unsigned int period, unsigned int interval, unsigned int count, const u8 *device_types, size_t dev_types_len, const u8 *ies, size_t ies_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>p2p_lo_start - Start offloading P2P listen to device : Private driver interface data : Listening frequency (MHz) for P2P listen : Length of the listen operation in milliseconds : Interval for running the listen operation in milliseconds : Number of times to run the listen operation : Device primary and secondary types : Number of bytes for device_types : P2P IE and WSC IE for Probe Response frames : Length of ies in bytes Returns: 0 on success or -1 on failure </p>

</div>
</div>
<a class="anchor" id="a060b2746682d32aaaa04bd39f84fdc0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::p2p_lo_stop)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>p2p_lo_stop - Stop P2P listen offload : Private driver interface data Returns: 0 on success or -1 on failure </p>

</div>
</div>
<a class="anchor" id="a7b9577cd055c0e48faa08be273119127"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* wpa_driver_ops::poll)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>poll - Poll driver for association information : private driver interface data</p>
<p>This is an option callback that can be used when the driver does not provide event mechanism for association events. This is called when receiving WPA EAPOL-Key messages that require association information. The driver interface is supposed to generate associnfo event before returning from this callback function. In addition, the driver interface should generate an association event after having sent out associnfo. </p>

</div>
</div>
<a class="anchor" id="a1c6ef4c7848e78dee3838afaba9a58f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* wpa_driver_ops::poll_client)(void *priv, const u8 *own_addr, const u8 *addr, int qos)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>poll_client - Probe (null data or such) the given station : Private driver interface data : MAC address of sending interface : MAC address of the station to probe : Indicates whether station is QoS station</p>
<p>This function is used to verify whether an associated station is still present. This function does not need to be implemented if the driver provides such inactivity polling mechanism. </p>

</div>
</div>
<a class="anchor" id="a81eb2531b752a54d2fbec3fefd74b514"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::probe_req_report)(void *priv, int report)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>probe_req_report - Request Probe Request frames to be indicated : Private driver interface data : Whether to report received Probe Request frames Returns: 0 on success, -1 on failure (or if not supported)</p>
<p>This command can be used to request the driver to indicate when Probe Request frames are received with EVENT_RX_PROBE_REQ events. Since this operation may require extra resources, e.g., due to less optimal hardware/firmware RX filtering, many drivers may disable Probe Request reporting at least in station mode. This command is used to notify the driver when the Probe Request frames need to be reported, e.g., during remain-on-channel operations. </p>

</div>
</div>
<a class="anchor" id="a25dfa05f992ff0180ca3435b14a7a898"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::radio_disable)(void *priv, int disabled)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>radio_disable - Disable/enable radio : Private driver interface data : 1=disable 0=enable radio Returns: 0 on success, -1 on failure</p>
<p>This optional command is for testing purposes. It can be used to disable the radio on a testbed device to simulate out-of-radio-range conditions. </p>

</div>
</div>
<a class="anchor" id="ab6afc2b66c0ec459b7b052502c03fad4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::read_sta_data)(void *priv, struct <a class="el" href="structhostap__sta__driver__data.html">hostap_sta_driver_data</a> *data, const u8 *addr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>read_sta_data - Fetch station data : Private driver interface data : Buffer for returning station information : MAC address of the station Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a04cf3039e7b8ea6473793fbbcd7be0a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::remain_on_channel)(void *priv, unsigned int <a class="el" href="structfreq.html">freq</a>, unsigned int duration)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>remain_on_channel - Remain awake on a channel : Private driver interface data : Frequency (in MHz) of the channel : Duration in milliseconds Returns: 0 on success, -1 on failure</p>
<p>This command is used to request the driver to remain awake on the specified channel for the specified duration and report received Action frames with EVENT_RX_MGMT events. Optionally, received Probe Request frames may also be requested to be reported by calling <a class="el" href="structwpa__driver__ops.html#a81eb2531b752a54d2fbec3fefd74b514">probe_req_report()</a>. These will be reported with EVENT_RX_PROBE_REQ.</p>
<p>The driver may not be at the requested channel when this function returns, i.e., the return code is only indicating whether the request was accepted. The caller will need to wait until the EVENT_REMAIN_ON_CHANNEL event indicates that the driver has completed the channel change. This may take some time due to other need for the radio and the caller should be prepared to timing out its wait since there are no guarantees on when this request can be executed. </p>

</div>
</div>
<a class="anchor" id="a5101fd0e80c8343439c6741facb9f7d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::remove_pmkid)(void *priv, const u8 *bssid, const u8 *pmkid)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>remove_pmkid - Remove PMKSA cache entry to the driver : private driver interface data : BSSID for the PMKSA cache entry : PMKID for the PMKSA cache entry</p>
<p>Returns: 0 on success, -1 on failure</p>
<p>This function is called when the supplicant drops a PMKSA cache entry for any reason.</p>
<p>If the driver generates RSN IE, i.e., it does not use wpa_ie in <a class="el" href="structwpa__driver__ops.html#aab2985f9322b4e24f53508a164479d62">associate()</a>, <a class="el" href="structwpa__driver__ops.html#a5101fd0e80c8343439c6741facb9f7d6">remove_pmkid()</a> can be used to synchronize PMKSA caches between the driver and wpa_supplicant. If the driver uses wpa_ie from wpa_supplicant, this driver_ops function does not need to be implemented. Likewise, if the driver does not support WPA, this function is not needed. </p>

</div>
</div>
<a class="anchor" id="ae66001b81c27f2e3b1f1321b9a6ca872"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* wpa_driver_ops::resume)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>resume - Notification on system resume/thaw event : Private driver interface data </p>

</div>
</div>
<a class="anchor" id="a307154101021ae2dc8eaf58e12e7828e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::roaming)(void *priv, int allowed, const u8 *bssid)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>roaming - Set roaming policy for driver-based BSS selection : Private driver interface data : Whether roaming within ESS is allowed : Forced BSSID if roaming is disabled or NULL if not set Returns: Length of written status information or -1 on failure</p>
<p>This optional callback can be used to update roaming policy from the <a class="el" href="structwpa__driver__ops.html#aab2985f9322b4e24f53508a164479d62">associate()</a> command (bssid being set there indicates that the driver should not roam before getting this <a class="el" href="structwpa__driver__ops.html#a307154101021ae2dc8eaf58e12e7828e">roaming()</a> call to allow roaming. If the driver does not indicate WPA_DRIVER_FLAGS_BSS_SELECTION capability, roaming policy is handled within wpa_supplicant and there is no need to implement or react to this callback. </p>

</div>
</div>
<a class="anchor" id="a0a0accf1567d49af5b20b6344189e72b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::scan2)(void *priv, struct <a class="el" href="structwpa__driver__scan__params.html">wpa_driver_scan_params</a> *params)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>scan2 - Request the driver to initiate scan : private driver interface data : Scan parameters</p>
<p>Returns: 0 on success, -1 on failure</p>
<p>Once the scan results are ready, the driver should report scan results event for wpa_supplicant which will eventually request the results with wpa_driver_get_scan_results2(). </p>

</div>
</div>
<a class="anchor" id="ab8b955c967dde49f7ca40c779ed1bfd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::sched_scan)(void *priv, struct <a class="el" href="structwpa__driver__scan__params.html">wpa_driver_scan_params</a> *params)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sched_scan - Request the driver to initiate scheduled scan : Private driver interface data : Scan parameters Returns: 0 on success, -1 on failure</p>
<p>This operation should be used for scheduled scan offload to the hardware. Every time scan results are available, the driver should report scan results event for wpa_supplicant which will eventually request the results with wpa_driver_get_scan_results2(). This operation is optional and if not provided or if it returns -1, we fall back to normal host-scheduled scans. </p>

</div>
</div>
<a class="anchor" id="a8e6fb296d9636933a14c24ae4a2aa602"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::send_action)(void *priv, unsigned int <a class="el" href="structfreq.html">freq</a>, unsigned int wait, const u8 *dst, const u8 *src, const u8 *bssid, const u8 *data, size_t data_len, int no_cck)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>send_action - Transmit an Action frame : Private driver interface data : Frequency (in MHz) of the channel : Time to wait off-channel for a response (in ms), or zero : Destination MAC address (Address 1) : Source MAC address (Address 2) : BSSID (Address 3) : Frame body : data length in octets @ : Whether CCK rates must not be used to transmit this frame Returns: 0 on success, -1 on failure</p>
<p>This command can be used to request the driver to transmit an action frame to the specified destination.</p>
<p>If the WPA_DRIVER_FLAGS_OFFCHANNEL_TX flag is set, the frame will be transmitted on the given channel and the device will wait for a response on that channel for the given wait time.</p>
<p>If the flag is not set, the wait time will be ignored. In this case, if a remain-on-channel duration is in progress, the frame must be transmitted on that channel; alternatively the frame may be sent on the current operational channel (if in associated state in station mode or while operating as an AP.) </p>

</div>
</div>
<a class="anchor" id="a72a1ef06c0be3c114c2ad69d98928ce8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* wpa_driver_ops::send_action_cancel_wait)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>send_action_cancel_wait - Cancel action frame TX wait : Private driver interface data</p>
<p>This command cancels the wait time associated with sending an action frame. It is only available when WPA_DRIVER_FLAGS_OFFCHANNEL_TX is set in the driver flags. </p>

</div>
</div>
<a class="anchor" id="a8c026ee9353fd2f9bac05a5cd5695f2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::send_ether)(void *priv, const u8 *dst, const u8 *src, u16 proto, const u8 *data, size_t data_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>send_ether - Send an ethernet packet (AP only) : private driver interface data : Destination MAC address : Source MAC address : Ethertype : EAPOL packet starting with IEEE 802.1X header : Length of the EAPOL packet in octets Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a620e056cede30098fc42ba4eec5711b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::send_frame)(void *priv, const u8 *data, size_t data_len, int encrypt)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>send_frame - Send IEEE 802.11 frame (testing use only) : Private driver interface data : IEEE 802.11 frame with IEEE 802.11 header : Size of the frame : Whether to encrypt the frame (if keys are set) Returns: 0 on success, -1 on failure</p>
<p>This function is only used for debugging purposes and is not required to be implemented for normal operations. </p>

</div>
</div>
<a class="anchor" id="acc17be00e77c9133ac3e0f451d3b286b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::send_mlme)(void *priv, const u8 *data, size_t data_len, int noack, unsigned int <a class="el" href="structfreq.html">freq</a>, const u16 *csa_offs, size_t csa_offs_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>send_mlme - Send management frame from MLME : Private driver interface data : IEEE 802.11 management frame with IEEE 802.11 header : Size of the management frame : Do not wait for this frame to be acked (disable retries) : Frequency (in MHz) to send the frame on, or 0 to let the driver decide : Array of CSA offsets or NULL : Number of elements in csa_offs Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="aafc38009de4111afe59f1c528b486d8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::send_tdls_mgmt)(void *priv, const u8 *dst, u8 action_code, u8 dialog_token, u16 status_code, u32 peer_capab, int initiator, const u8 *buf, size_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>send_tdls_mgmt - for sending TDLS management packets : private driver interface data : Destination (peer) MAC address : TDLS action code for the mssage : Dialog Token to use in the message (if needed) : Status Code or Reason Code to use (if needed) : TDLS peer capability (TDLS_PEER_* bitfield) : Is the current end the TDLS link initiator : TDLS IEs to add to the message : Length of buf in octets Returns: 0 on success, negative (&lt;0) on failure</p>
<p>This optional function can be used to send packet to driver which is responsible for receiving and sending all TDLS packets. </p>

</div>
</div>
<a class="anchor" id="a14d7fb4d5cb7ec7f9d2c208486e326c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_acl)(void *priv, struct <a class="el" href="structhostapd__acl__params.html">hostapd_acl_params</a> *params)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_acl - Set ACL in AP mode : Private driver interface data : Parameters to configure ACL Returns: 0 on success, -1 on failure</p>
<p>This is used only for the drivers which support MAC address ACL. </p>

</div>
</div>
<a class="anchor" id="a565bd07356ac6f552a692cfd72b448ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_ap)(void *priv, struct <a class="el" href="structwpa__driver__ap__params.html">wpa_driver_ap_params</a> *params)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_ap - Set Beacon and Probe Response information for AP mode : Private driver interface data : Parameters to use in AP mode</p>
<p>This function is used to configure Beacon template and/or extra IEs to add for Beacon and Probe Response frames for the driver in AP mode. The driver is responsible for building the full Beacon frame by concatenating the head part with TIM IE generated by the driver/firmware and finishing with the tail part. Depending on the driver architectue, this can be done either by using the full template or the set of additional IEs (e.g., WPS and P2P IE). Similarly, Probe Response processing depends on the driver design. If the driver (or firmware) takes care of replying to Probe Request frames, the extra IEs provided here needs to be added to the Probe Response frames.</p>
<p>Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a909209b67c96d91c1d6b634f1ab45786"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_ap_wps_ie)(void *priv, const struct <a class="el" href="structwpabuf.html">wpabuf</a> *beacon, const struct <a class="el" href="structwpabuf.html">wpabuf</a> *proberesp, const struct <a class="el" href="structwpabuf.html">wpabuf</a> *assocresp)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_ap_wps_ie - Add WPS IE(s) into Beacon/Probe Response frames (AP) : Private driver interface data : WPS IE(s) for Beacon frames or NULL to remove extra IE(s) : WPS IE(s) for Probe Response frames or NULL to remove extra IE(s) : WPS IE(s) for (Re)Association Response frames or NULL to remove extra IE(s) Returns: 0 on success, -1 on failure</p>
<p>This is an optional function to add WPS IE in the kernel driver for Beacon and Probe Response frames. This can be left undefined (set to NULL) if the driver uses the Beacon template from <a class="el" href="structwpa__driver__ops.html#a565bd07356ac6f552a692cfd72b448ec">set_ap()</a> and does not process Probe Request frames. If the driver takes care of (Re)Association frame processing, the assocresp buffer includes WPS IE(s) that need to be added to (Re)Association Response frames whenever a (Re)Association Request frame indicated use of WPS.</p>
<p>This will also be used to add P2P IE(s) into Beacon/Probe Response frames when operating as a GO. The driver is responsible for adding timing related attributes (e.g., NoA) in addition to the IEs included here by appending them after these buffers. This call is also used to provide Probe Response IEs for P2P Listen state operations for drivers that generate the Probe Response frames internally.</p>
<p>DEPRECATED - use <a class="el" href="structwpa__driver__ops.html#a565bd07356ac6f552a692cfd72b448ec">set_ap()</a> instead </p>

</div>
</div>
<a class="anchor" id="a99558d6babc80d70a1cb889683d4ae8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_authmode)(void *priv, int authmode)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_authmode - Set authentication algorithm(s) for static WEP : Private driver interface data : 1=Open System, 2=Shared Key, 3=both Returns: 0 on success, -1 on failure</p>
<p>This function can be used to set authentication algorithms for AP mode when static WEP is used. If the driver uses user space MLME/SME implementation, there is no need to implement this function.</p>
<p>DEPRECATED - use <a class="el" href="structwpa__driver__ops.html#a565bd07356ac6f552a692cfd72b448ec">set_ap()</a> instead </p>

</div>
</div>
<a class="anchor" id="ae47442c1d785b0dc51a406f9921f7b4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_band)(void *priv, enum set_band <a class="el" href="structband.html">band</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_band - Notify driver of band selection : Private driver interface data : The selected <a class="el" href="structband.html">band(s)</a> Returns 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a624aa6019f0a29c3a977edf524f24f0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_countermeasures)(void *priv, int enabled)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_countermeasures - Enable/disable TKIP countermeasures : private driver interface data : 1 = countermeasures enabled, 0 = disabled</p>
<p>Returns: 0 on success, -1 on failure</p>
<p>Configure TKIP countermeasures. When these are enabled, the driver should drop all received and queued frames that are using TKIP. </p>

</div>
</div>
<a class="anchor" id="aa9ae4fc64d0507ebdf0e1c98875b5184"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_country)(void *priv, const char *alpha2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_country - Set country : Private driver interface data : country to which to switch to Returns: 0 on success, -1 on failure</p>
<p>This function is for drivers which support some form of setting a regulatory domain. </p>

</div>
</div>
<a class="anchor" id="a06535bc5f8e20b5bc5041fbe6d7dd51e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_default_scan_ies)(void *priv, const u8 *ies, size_t ies_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_default_scan_ies - Set default scan IEs : Private driver interface data : Scan default IEs buffer : Length of IEs in bytes Returns: 0 on success or -1 on failure</p>
<p>The driver can use these by default when there are no scan IEs coming in the subsequent scan requests. Also in case of one or more of IEs given in <a class="el" href="structwpa__driver__ops.html#a06535bc5f8e20b5bc5041fbe6d7dd51e">set_default_scan_ies()</a> are missing in the subsequent scan request, the driver should merge the missing scan IEs in the scan request from the IEs set by <a class="el" href="structwpa__driver__ops.html#a06535bc5f8e20b5bc5041fbe6d7dd51e">set_default_scan_ies()</a> in the Probe Request frames sent. </p>

</div>
</div>
<a class="anchor" id="a294bd2b3887e938595ba24025cc82ded"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_frag)(void *priv, int frag)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_frag - Set fragmentation threshold : Private driver interface data : Fragmentation threshold in octets Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a5f78a8a4580531be375b0f99c5848eeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_freq)(void *priv, struct <a class="el" href="structhostapd__freq__params.html">hostapd_freq_params</a> *<a class="el" href="structfreq.html">freq</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_freq - Set channel/frequency (AP only) : Private driver interface data : Channel parameters Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a22098eada1a8802e56bf2651a5eb5516"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_generic_elem)(void *priv, const u8 *elem, size_t elem_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_generic_elem - Add IEs into Beacon/Probe Response frames (AP) : Private driver interface data : Information elements : Length of the elem buffer in octets Returns: 0 on success, -1 on failure</p>
<p>This is an optional function to add information elements in the kernel driver for Beacon and Probe Response frames. This can be left undefined (set to NULL) if the driver uses the Beacon template from <a class="el" href="structwpa__driver__ops.html#a565bd07356ac6f552a692cfd72b448ec">set_ap()</a>.</p>
<p>DEPRECATED - use <a class="el" href="structwpa__driver__ops.html#a565bd07356ac6f552a692cfd72b448ec">set_ap()</a> instead </p>

</div>
</div>
<a class="anchor" id="a5a96b55cccf5b13306c2f1ec6ad00834"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_ieee8021x)(void *priv, struct <a class="el" href="structwpa__bss__params.html">wpa_bss_params</a> *params)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_ieee8021x - Enable/disable IEEE 802.1X support (AP only) : Private driver interface data : BSS parameters Returns: 0 on success, -1 on failure</p>
<p>This is an optional function to configure the kernel driver to enable/disable IEEE 802.1X support and set WPA/WPA2 parameters. This can be left undefined (set to NULL) if IEEE 802.1X support is always enabled and the driver uses <a class="el" href="structwpa__driver__ops.html#a565bd07356ac6f552a692cfd72b448ec">set_ap()</a> to set WPA/RSN IE for Beacon frames.</p>
<p>DEPRECATED - use <a class="el" href="structwpa__driver__ops.html#a565bd07356ac6f552a692cfd72b448ec">set_ap()</a> instead </p>

</div>
</div>
<a class="anchor" id="aa7011114b84f8cac06bfb4a54e5ec43e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_key)(const char *ifname, void *priv, enum wpa_alg alg, const u8 *addr, int key_idx, int set_tx, const u8 *seq, size_t seq_len, const u8 *key, size_t key_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_key - Configure encryption key : Interface name (for multi-SSID/VLAN support) : private driver interface data : encryption algorithm (WPA_ALG_NONE, WPA_ALG_WEP, WPA_ALG_TKIP, WPA_ALG_CCMP, WPA_ALG_IGTK, WPA_ALG_PMK, WPA_ALG_GCMP, WPA_ALG_GCMP_256, WPA_ALG_CCMP_256, WPA_ALG_BIP_GMAC_128, WPA_ALG_BIP_GMAC_256, WPA_ALG_BIP_CMAC_256); WPA_ALG_NONE clears the key. : Address of the peer STA (BSSID of the current AP when setting pairwise key in station mode), ff:ff:ff:ff:ff:ff for broadcast keys, NULL for default keys that are used both for broadcast and unicast; when clearing keys, NULL is used to indicate that both the broadcast-only and default key of the specified key index is to be cleared : key index (0..3), usually 0 for unicast keys; 0..4095 for IGTK : configure this key as the default Tx key (only used when driver does not support separate unicast/individual key : sequence number/packet number, seq_len octets, the next packet number to be used for in replay protection; configured for Rx keys (in most cases, this is only used with broadcast keys and set to zero for unicast keys); NULL if not set : length of the seq, depends on the algorithm: TKIP: 6 octets, CCMP/GCMP: 6 octets, IGTK: 6 octets : key buffer; TKIP: 16-byte temporal key, 8-byte Tx Mic key, 8-byte Rx Mic Key : length of the key buffer in octets (WEP: 5 or 13, TKIP: 32, CCMP/GCMP: 16, IGTK: 16)</p>
<p>Returns: 0 on success, -1 on failure</p>
<p>Configure the given key for the kernel driver. If the driver supports separate individual keys (4 default keys + 1 individual), addr can be used to determine whether the key is default or individual. If only 4 keys are supported, the default key with key index 0 is used as the individual key. STA must be configured to use it as the default Tx key (set_tx is set) and accept Rx for all the key indexes. In most cases, WPA uses only key indexes 1 and 2 for broadcast keys, so key index 0 is available for this kind of configuration.</p>
<p>Please note that TKIP keys include separate TX and RX MIC keys and some drivers may expect them in different order than wpa_supplicant is using. If the TX/RX keys are swapped, all TKIP encrypted packets will trigger Michael MIC errors. This can be fixed by changing the order of MIC keys by swapping te bytes 16..23 and 24..31 of the key in driver_*.c <a class="el" href="structwpa__driver__ops.html#aa7011114b84f8cac06bfb4a54e5ec43e">set_key()</a> implementation, see driver_ndis.c for an example on how this can be done. </p>

</div>
</div>
<a class="anchor" id="ab507297b8ccce4b498f77c4875a4f53d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_mac_addr)(void *priv, const u8 *addr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_mac_addr - Set MAC address : Private driver interface data : MAC address to use or NULL for setting back to permanent Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="ac72b74bf5f4d588864ad99b65580871f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_noa)(void *priv, u8 count, int start, int duration)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_noa - Set Notice of Absence parameters for GO (testing) : Private driver interface data : Count : Start time in ms from next TBTT : Duration in ms Returns: 0 on success or -1 on failure</p>
<p>This function is used to set Notice of Absence parameters for GO. It is used only for testing. To disable NoA, all parameters are set to 0. </p>

</div>
</div>
<a class="anchor" id="ab822dded24230639aff78955355bf022"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_operstate)(void *priv, int state)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_operstate - Sets device operating state to DORMANT or UP : private driver interface data : 0 = dormant, 1 = up Returns: 0 on success, -1 on failure</p>
<p>This is an optional function that can be used on operating systems that support a concept of controlling network device state from user space applications. This function, if set, gets called with state = 1 when authentication has been completed and with state = 0 when connection is lost. </p>

</div>
</div>
<a class="anchor" id="a4ac75e2f7adc121b3a98e89e058cf148"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_p2p_powersave)(void *priv, int legacy_ps, int opp_ps, int ctwindow)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_p2p_powersave - Set P2P power save options : Private driver interface data : 0 = disable, 1 = enable, 2 = maximum PS, -1 = no change : 0 = disable, 1 = enable, -1 = no change : 0.. = change (msec), -1 = no change Returns: 0 on success or -1 on failure </p>

</div>
</div>
<a class="anchor" id="a11566ca9790ee3da508cc3d221c50230"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_param)(void *priv, const char *param)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_param - Set driver configuration parameters : private driver interface data from <a class="el" href="structwpa__driver__ops.html#a247e66445054de570b291854b1b4de2d">init()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td>driver specific configuration parameters</td></tr>
  </table>
  </dd>
</dl>
<p>Returns: 0 on success, -1 on failure</p>
<p>Optional handler for notifying driver interface about configuration parameters (driver_param). </p>

</div>
</div>
<a class="anchor" id="acd9e5e75655df6b41f95ec143ac0c1fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_privacy)(void *priv, int enabled)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_privacy - Enable/disable privacy (AP only) : Private driver interface data : 1 = privacy enabled, 0 = disabled Returns: 0 on success, -1 on failure</p>
<p>This is an optional function to configure privacy field in the kernel driver for Beacon frames. This can be left undefined (set to NULL) if the driver uses the Beacon template from <a class="el" href="structwpa__driver__ops.html#a565bd07356ac6f552a692cfd72b448ec">set_ap()</a>.</p>
<p>DEPRECATED - use <a class="el" href="structwpa__driver__ops.html#a565bd07356ac6f552a692cfd72b448ec">set_ap()</a> instead </p>

</div>
</div>
<a class="anchor" id="abf9f4b56abe1d2bdf4845a4e54d42a91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_prob_oper_freq)(void *priv, unsigned int <a class="el" href="structfreq.html">freq</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_prob_oper_freq - Indicate probable P2P operating channel : Private driver interface data : Channel frequency in MHz Returns 0 on success, -1 on failure</p>
<p>This command can be used to inform the driver of the operating frequency that an ongoing P2P group formation is likely to come up on. Local device is assuming P2P Client role. </p>

</div>
</div>
<a class="anchor" id="ad7260b85f0cf10b490e11b191580ce63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_qos_map)(void *priv, const u8 *qos_map_set, u8 qos_map_set_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_qos_map - Set QoS Map : Private driver interface data : QoS Map : Length of QoS Map </p>

</div>
</div>
<a class="anchor" id="a67f049882e6503d366b15a0f3ee9a841"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_radius_acl_auth)(void *priv, const u8 *mac, int accepted, u32 session_timeout)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_radius_acl_auth - Notification of RADIUS ACL change : Private driver interface data : MAC address of the station : Whether the station was accepted : Session timeout for the station Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a2b0152e7898994c4a398bc5f37e17aa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_radius_acl_expire)(void *priv, const u8 *mac)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_radius_acl_expire - Notification of RADIUS ACL expiration : Private driver interface data : MAC address of the station Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a2960f7a5677e6c44247bd1a52d4fb897"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* wpa_driver_ops::set_rekey_info)(void *priv, const u8 *kek, size_t kek_len, const u8 *kck, size_t kck_len, const u8 *replay_ctr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_rekey_info - Set rekey information : Private driver interface data : Current KEK : KEK length in octets : Current KCK : KCK length in octets : Current EAPOL-Key Replay Counter</p>
<p>This optional function can be used to provide information for the driver/firmware to process EAPOL-Key frames in Group Key Handshake while the host (including wpa_supplicant) is sleeping. </p>

</div>
</div>
<a class="anchor" id="a09ceeac95efc0eed7247f1af0165c9ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_rts)(void *priv, int rts)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_rts - Set RTS threshold : Private driver interface data : RTS threshold in octets Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a97ea30f33fc58b2f2aeb41d44950e94e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_sta_vlan)(void *priv, const u8 *addr, const char *ifname, int vlan_id)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_sta_vlan - Bind a station into a specific interface (AP only) : Private driver interface data : Interface (main or virtual BSS or VLAN) : MAC address of the associated station : VLAN ID Returns: 0 on success, -1 on failure</p>
<p>This function is used to bind a station to a specific virtual interface. It is only used if when virtual interfaces are supported, e.g., to assign stations to different VLAN interfaces based on information from a RADIUS server. This allows separate broadcast domains to be used with a single BSS. </p>

</div>
</div>
<a class="anchor" id="ad83401c2c838161cf9fbdb5415bceb4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_supp_port)(void *priv, int authorized)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_supp_port - Set IEEE 802.1X Supplicant Port status : Private driver interface data : Whether the port is authorized Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a8afda74c5da7d5497888c365c98bd6e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_tx_queue_params)(void *priv, int queue, int aifs, int cw_min, int cw_max, int burst_time)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_tx_queue_params - Set TX queue parameters : Private driver interface data : Queue number (0 = VO, 1 = VI, 2 = BE, 3 = BK) : AIFS : cwMin : cwMax : Maximum length for bursting in 0.1 msec units </p>

</div>
</div>
<a class="anchor" id="a3169a191fd2fced4c113955ca32c5569"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_wds_sta)(void *priv, const u8 *addr, int aid, int val, const char *bridge_ifname, char *ifname_wds)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_wds_sta - Bind a station into a 4-address WDS (AP only) : Private driver interface data : MAC address of the associated station : Association ID : 1 = bind to 4-address WDS; 0 = unbind : Bridge interface to use for the WDS station or NULL to indicate that bridge is not to be used : Buffer to return the interface name for the new WDS station or NULL to indicate name is not returned. Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a7d5b780854dbcca5bfb36ed32020ceda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::set_wowlan)(void *priv, const struct <a class="el" href="structwowlan__triggers.html">wowlan_triggers</a> *triggers)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set_wowlan - Set wake-on-wireless triggers : Private driver interface data : wowlan triggers </p>

</div>
</div>
<a class="anchor" id="a7cdd0f6da5aa64b3f214f613cbc76e6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::signal_monitor)(void *priv, int threshold, int hysteresis)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>signal_monitor - Set signal monitoring parameters : Private driver interface data : Threshold value for signal change events; 0 = disabled : Minimum change in signal strength before indicating a new event Returns: 0 on success, -1 on failure (or if not supported)</p>
<p>This function can be used to configure monitoring of signal strength with the current AP. Whenever signal strength drops below the threshold value or increases above it, EVENT_SIGNAL_CHANGE event should be generated assuming the signal strength has changed at least hysteresis from the previously indicated signal change event. </p>

</div>
</div>
<a class="anchor" id="a28328e27ee31b61aec151a7a2a949172"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::signal_poll)(void *priv, struct <a class="el" href="structwpa__signal__info.html">wpa_signal_info</a> *signal_info)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>signal_poll - Get current connection information : Private driver interface data : Connection info structure </p>

</div>
</div>
<a class="anchor" id="abbe2c644ed40d088200d2f12530ff1d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::sta_add)(void *priv, struct <a class="el" href="structhostapd__sta__add__params.html">hostapd_sta_add_params</a> *params)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sta_add - Add a station entry : Private driver interface data : Station parameters Returns: 0 on success, -1 on failure</p>
<p>This function is used to add or set (params-&gt;set 1) a station entry in the driver. Adding STA entries is used only if the driver does not take care of association processing.</p>
<p>With drivers that don't support full AP client state, this function is used to add a station entry to the driver once the station has completed association.</p>
<p>With TDLS, this function is used to add or set (params-&gt;set 1) TDLS peer entries (even with drivers that do not support full AP client state). </p>

</div>
</div>
<a class="anchor" id="a41ef949e8c95577db9e8a9a0c0ee26bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::sta_assoc)(void *priv, const u8 *own_addr, const u8 *addr, int reassoc, u16 <a class="el" href="structwpa__driver__ops.html#a19641636b640f7b776ebbc9e86bbbe66">status</a>, const u8 *ie, size_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sta_assoc - Station association indication : Private driver interface data : Source address and BSSID for association frame : MAC address of the station to associate : flag to indicate re-association : association response status code : assoc response ie buffer : ie buffer length Returns: 0 on success, -1 on failure</p>
<p>This function indicates the driver to send (Re)Association Response frame to the station. </p>

</div>
</div>
<a class="anchor" id="a98dc682e1edcd54530847f555e2594b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::sta_auth)(void *priv, const u8 *own_addr, const u8 *addr, u16 seq, u16 <a class="el" href="structwpa__driver__ops.html#a19641636b640f7b776ebbc9e86bbbe66">status</a>, const u8 *ie, size_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sta_auth - Station authentication indication : Private driver interface data : Source address and BSSID for authentication frame : MAC address of the station to associate : authentication sequence number : authentication response status code : authentication frame ie buffer : ie buffer length</p>
<p>This function indicates the driver to send Authentication frame to the station. </p>

</div>
</div>
<a class="anchor" id="a5570c6efea13d6d8c0c6212968ec9022"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::sta_clear_stats)(void *priv, const u8 *addr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sta_clear_stats - Clear station statistics (AP only) : Private driver interface data : Station address Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a4da84de2fb37cbf5e5f58fc2029bd90e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::sta_deauth)(void *priv, const u8 *own_addr, const u8 *addr, int reason)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sta_deauth - Deauthenticate a station (AP only) : Private driver interface data : Source address and BSSID for the Deauthentication frame : MAC address of the station to deauthenticate : Reason code for the Deauthentiation frame Returns: 0 on success, -1 on failure</p>
<p>This function requests a specific station to be deauthenticated and a Deauthentication frame to be sent to it. </p>

</div>
</div>
<a class="anchor" id="acf8c3154617e6071ca13c4bdf1672101"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::sta_disassoc)(void *priv, const u8 *own_addr, const u8 *addr, int reason)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sta_disassoc - Disassociate a station (AP only) : Private driver interface data : Source address and BSSID for the Disassociation frame : MAC address of the station to disassociate : Reason code for the Disassociation frame Returns: 0 on success, -1 on failure</p>
<p>This function requests a specific station to be disassociated and a Disassociation frame to be sent to it. </p>

</div>
</div>
<a class="anchor" id="ac518b3ba9121879cbd5b935ddd18a495"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::sta_remove)(void *priv, const u8 *addr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sta_remove - Remove a station entry (AP only) : Private driver interface data : MAC address of the station to be removed Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="af982067929096b4955e1281fa5fdd2c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::sta_set_flags)(void *priv, const u8 *addr, unsigned int total_flags, unsigned int flags_or, unsigned int flags_and)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sta_set_flags - Set station flags (AP only) : Private driver interface data : Station address : Bitmap of all WPA_STA_* flags currently set : Bitmap of WPA_STA_* flags to add : Bitmap of WPA_STA_* flags to us as a mask Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a33da6323af8d710ab778f8e68689d737"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::start_dfs_cac)(void *priv, struct <a class="el" href="structhostapd__freq__params.html">hostapd_freq_params</a> *<a class="el" href="structfreq.html">freq</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>start_dfs_cac - Listen for radar interference on the channel : Private driver interface data : Channel parameters Returns: 0 on success, -1 on failure </p>

</div>
</div>
<a class="anchor" id="a19641636b640f7b776ebbc9e86bbbe66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::status)(void *priv, char *buf, size_t buflen)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>status - Get driver interface status information : Private driver interface data : Buffer for printing tou the status information : Maximum length of the buffer Returns: Length of written status information or -1 on failure </p>

</div>
</div>
<a class="anchor" id="a8445cefc2710817ea37996e6fb95e9c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::stop_ap)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>stop_ap - Removes beacon from AP : Private driver interface data Returns: 0 on success, -1 on failure (or if not supported)</p>
<p>This optional function can be used to disable AP mode related configuration. Unlike deinit_ap, it does not change to station mode. </p>

</div>
</div>
<a class="anchor" id="a85b60e49d569f230dc6499bb5a4ab409"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::stop_sched_scan)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>stop_sched_scan - Request the driver to stop a scheduled scan : Private driver interface data Returns: 0 on success, -1 on failure</p>
<p>This should cause the scheduled scan to be stopped and results should stop being sent. Must be supported if sched_scan is supported. </p>

</div>
</div>
<a class="anchor" id="a4e3f72b49ec3feeeb14332db68762f5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* wpa_driver_ops::suspend)(void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>suspend - Notification on system suspend/hibernate event : Private driver interface data </p>

</div>
</div>
<a class="anchor" id="a369c25de648f7743032657f29c62cb6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::switch_channel)(void *priv, struct <a class="el" href="structcsa__settings.html">csa_settings</a> *settings)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>switch_channel - Announce channel switch and migrate the GO to the given frequency : Private driver interface data : Settings for CSA period and new channel Returns: 0 on success, -1 on failure</p>
<p>This function is used to move the GO to the legacy STA channel to avoid frequency conflict in single channel concurrency. </p>

</div>
</div>
<a class="anchor" id="a9ac8c9398b2236a27c4494fa8d58209b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::tdls_disable_channel_switch)(void *priv, const u8 *addr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable channel switching with TDLS peer : Private driver interface data : MAC address of the TDLS peer Returns: 0 on success, -1 on failure</p>
<p>This function indicates to the driver that it should stop switching with a given TDLS peer. </p>

</div>
</div>
<a class="anchor" id="a42e4e9d413656b73d88d12e0471d34f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::tdls_enable_channel_switch)(void *priv, const u8 *addr, u8 oper_class, const struct <a class="el" href="structhostapd__freq__params.html">hostapd_freq_params</a> *params)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable channel-switching with TDLS peer : Private driver interface data : MAC address of the TDLS peer : Operating class of the switch channel : Channel specification Returns: 0 on success, -1 on failure</p>
<p>The function indicates to driver that it can start switching to a different channel with a specified TDLS peer. The switching is assumed on until canceled with <a class="el" href="structwpa__driver__ops.html#a9ac8c9398b2236a27c4494fa8d58209b">tdls_disable_channel_switch()</a>. </p>

</div>
</div>
<a class="anchor" id="a2c72802a9074643f5c16947f7885804a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::tdls_oper)(void *priv, enum tdls_oper oper, const u8 *peer)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>tdls_oper - Ask the driver to perform high-level TDLS operations : Private driver interface data : TDLS high-level operation. See enum tdls_oper : Destination (peer) MAC address Returns: 0 on success, negative (&lt;0) on failure</p>
<p>This optional function can be used to send high-level TDLS commands to the driver. </p>

</div>
</div>
<a class="anchor" id="aa0e8395f5f46a07d705020f2a2cf80f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::update_ft_ies)(void *priv, const u8 *md, const u8 *ies, size_t ies_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>update_ft_ies - Update FT (IEEE 802.11r) IEs : Private driver interface data : Mobility domain (2 octets) (also included inside ies) : FT IEs (MDIE, FTIE, ...) or NULL to remove IEs : Length of FT IEs in bytes Returns: 0 on success, -1 on failure</p>
<p>The supplicant uses this callback to let the driver know that keying material for FT is available and that the driver can use the provided IEs in the next message in FT authentication sequence.</p>
<p>This function is only needed for driver that support IEEE 802.11r (Fast BSS Transition). </p>

</div>
</div>
<a class="anchor" id="a04c150b7f5f7e750c5b8fc90aa22b419"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::vendor_cmd)(void *priv, unsigned int vendor_id, unsigned int subcmd, const u8 *data, size_t data_len, struct <a class="el" href="structwpabuf.html">wpabuf</a> *buf)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>vendor_cmd - Execute vendor specific command : Private driver interface data : Vendor id : Vendor command id : Vendor command parameters (NULL if no parameters) : Data length : Return buffer (NULL to ignore reply) Returns: 0 on success, negative (&lt;0) on failure</p>
<p>This function handles vendor specific commands that are passed to the driver/device. The command is identified by vendor id and command id. Parameters can be passed as argument to the command in the data buffer. Reply (if any) will be filled in the supplied return buffer.</p>
<p>The exact driver behavior is driver interface and vendor specific. As an example, this will be converted to a vendor specific cfg80211 command in case of the nl80211 driver interface. </p>

</div>
</div>
<a class="anchor" id="a6ec9b90e2f316c2a543b396dca292a48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* wpa_driver_ops::wnm_oper)(void *priv, enum wnm_oper oper, const u8 *peer, u8 *buf, u16 *buf_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wnm_oper - Notify driver of the WNM frame reception : Private driver interface data : WNM operation. See enum wnm_oper : Destination (peer) MAC address : Buffer for the driver to fill in (for getting IE) : Return the len of buf Returns: 0 on success, negative (&lt;0) on failure </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>src/drivers/<a class="el" href="driver_8h_source.html">driver.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 12 2017 21:13:48 for Ethanol modification of Hostapd by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
