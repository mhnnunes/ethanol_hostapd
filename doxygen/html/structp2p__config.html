<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Ethanol modification of Hostapd: p2p_config Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Ethanol modification of Hostapd
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structp2p__config-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">p2p_config Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="p2p_8h_source.html">p2p.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for p2p_config:</div>
<div class="dyncontent">
<div class="center"><img src="structp2p__config__coll__graph.png" border="0" usemap="#p2p__config_coll__map" alt="Collaboration graph"/></div>
<map name="p2p__config_coll__map" id="p2p__config_coll__map">
<area shape="rect" id="node2" href="structp2p__channels.html" title="p2p_channels" alt="" coords="31,112,133,139"/><area shape="rect" id="node3" href="structp2p__channels_1_1p2p__reg__class.html" title="p2p_channels::p2p_reg\l_class" alt="" coords="5,6,160,47"/><area shape="rect" id="node4" href="structp2p__channel.html" title="p2p_channel" alt="" coords="158,112,252,139"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a5e95c2907d3e12c38db01ad275d20a82"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a5e95c2907d3e12c38db01ad275d20a82">country</a> [3]</td></tr>
<tr class="separator:a5e95c2907d3e12c38db01ad275d20a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815704a6c088a5f78358288b651864a8"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a815704a6c088a5f78358288b651864a8">reg_class</a></td></tr>
<tr class="separator:a815704a6c088a5f78358288b651864a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c7e7676d4cdb62396d0c010d703104"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a77c7e7676d4cdb62396d0c010d703104">channel</a></td></tr>
<tr class="separator:a77c7e7676d4cdb62396d0c010d703104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29899639875e0d5cb27c5f8c724a188"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#ad29899639875e0d5cb27c5f8c724a188">channel_forced</a></td></tr>
<tr class="separator:ad29899639875e0d5cb27c5f8c724a188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65cc8fc867118291fea93d1b367e18d"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#ae65cc8fc867118291fea93d1b367e18d">op_reg_class</a></td></tr>
<tr class="separator:ae65cc8fc867118291fea93d1b367e18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad434b4bdab005781be88cf55a47369af"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#ad434b4bdab005781be88cf55a47369af">op_channel</a></td></tr>
<tr class="separator:ad434b4bdab005781be88cf55a47369af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be0ff6a1f3da2597db0512f2c0abe52"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a4be0ff6a1f3da2597db0512f2c0abe52">cfg_op_channel</a></td></tr>
<tr class="separator:a4be0ff6a1f3da2597db0512f2c0abe52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab109524c9ebfb53cc4fe538fae64019c"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structp2p__channels.html">p2p_channels</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#ab109524c9ebfb53cc4fe538fae64019c">channels</a></td></tr>
<tr class="separator:ab109524c9ebfb53cc4fe538fae64019c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902d89230147a02e5245513d7d5e0e2f"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structp2p__channels.html">p2p_channels</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a902d89230147a02e5245513d7d5e0e2f">cli_channels</a></td></tr>
<tr class="separator:a902d89230147a02e5245513d7d5e0e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6139b8ce7a4478035d31397588a65d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#aac6139b8ce7a4478035d31397588a65d">num_pref_chan</a></td></tr>
<tr class="separator:aac6139b8ce7a4478035d31397588a65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae903a0b0eda0c75cfe9df44767fb2566"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structp2p__channel.html">p2p_channel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#ae903a0b0eda0c75cfe9df44767fb2566">pref_chan</a></td></tr>
<tr class="separator:ae903a0b0eda0c75cfe9df44767fb2566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70525a656382fdd5789b7a1eb6fb44ef"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a70525a656382fdd5789b7a1eb6fb44ef">pri_dev_type</a> [8]</td></tr>
<tr class="separator:a70525a656382fdd5789b7a1eb6fb44ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81bed5e8fce37a4bf11f2f43d12aac33"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a81bed5e8fce37a4bf11f2f43d12aac33">sec_dev_type</a> [P2P_SEC_DEVICE_TYPES][8]</td></tr>
<tr class="separator:a81bed5e8fce37a4bf11f2f43d12aac33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d3a4014e072c43616fdf0ee427820b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a29d3a4014e072c43616fdf0ee427820b">num_sec_dev_types</a></td></tr>
<tr class="separator:a29d3a4014e072c43616fdf0ee427820b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2c0895e6785e03e48ed278dff7f95b"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#aaa2c0895e6785e03e48ed278dff7f95b">dev_addr</a> [ETH_ALEN]</td></tr>
<tr class="separator:aaa2c0895e6785e03e48ed278dff7f95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab49de1b6693f66f8b5a6d93aef5042"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a5ab49de1b6693f66f8b5a6d93aef5042">dev_name</a></td></tr>
<tr class="separator:a5ab49de1b6693f66f8b5a6d93aef5042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba742e33478927e7d7d69b048c1e65bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba742e33478927e7d7d69b048c1e65bf"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>manufacturer</b></td></tr>
<tr class="separator:aba742e33478927e7d7d69b048c1e65bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafd923ef479ba88875a2e7c3bdad98c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acafd923ef479ba88875a2e7c3bdad98c"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>model_name</b></td></tr>
<tr class="separator:acafd923ef479ba88875a2e7c3bdad98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef43c73ac55292fcf6c681095f66fb3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef43c73ac55292fcf6c681095f66fb3c"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>model_number</b></td></tr>
<tr class="separator:aef43c73ac55292fcf6c681095f66fb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f923720a41499fe84bda54179d5239"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82f923720a41499fe84bda54179d5239"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>serial_number</b></td></tr>
<tr class="separator:a82f923720a41499fe84bda54179d5239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc75f6e80262b9b21d1fae2853f9dd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dc75f6e80262b9b21d1fae2853f9dd4"></a>
u8&#160;</td><td class="memItemRight" valign="bottom"><b>uuid</b> [16]</td></tr>
<tr class="separator:a0dc75f6e80262b9b21d1fae2853f9dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2d88ffd91dc27edfa238489511e66c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb2d88ffd91dc27edfa238489511e66c"></a>
u16&#160;</td><td class="memItemRight" valign="bottom"><b>config_methods</b></td></tr>
<tr class="separator:afb2d88ffd91dc27edfa238489511e66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefda9c6e8accee27515c32da7ac3f00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#aeefda9c6e8accee27515c32da7ac3f00">concurrent_operations</a></td></tr>
<tr class="separator:aeefda9c6e8accee27515c32da7ac3f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9f4c368b4ebe83d7795358ee4faebe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#aeb9f4c368b4ebe83d7795358ee4faebe">max_peers</a></td></tr>
<tr class="separator:aeb9f4c368b4ebe83d7795358ee4faebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40051f8d8fd59fbd8f66eab6e726017f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a40051f8d8fd59fbd8f66eab6e726017f">p2p_intra_bss</a></td></tr>
<tr class="separator:a40051f8d8fd59fbd8f66eab6e726017f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f937e672c4ef68a2fa75611ad19613"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a89f937e672c4ef68a2fa75611ad19613">ssid_postfix</a> [SSID_MAX_LEN-9]</td></tr>
<tr class="separator:a89f937e672c4ef68a2fa75611ad19613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f2888ee0c102f10a65ead133779f6d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a42f2888ee0c102f10a65ead133779f6d">ssid_postfix_len</a></td></tr>
<tr class="separator:a42f2888ee0c102f10a65ead133779f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbfb310287390f176dc7394b3361094"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#adbbfb310287390f176dc7394b3361094">max_listen</a></td></tr>
<tr class="separator:adbbfb310287390f176dc7394b3361094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1e2511fa80afba207beb60e748741e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a6c1e2511fa80afba207beb60e748741e">passphrase_len</a></td></tr>
<tr class="separator:a6c1e2511fa80afba207beb60e748741e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecd14d341af12b06cf3a8826e8ebdda"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a5ecd14d341af12b06cf3a8826e8ebdda">cb_ctx</a></td></tr>
<tr class="separator:a5ecd14d341af12b06cf3a8826e8ebdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcec3d6fab31a2b8114fff1f97b9c8d5"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#abcec3d6fab31a2b8114fff1f97b9c8d5">debug_print</a> )(void *ctx, int level, const char *msg)</td></tr>
<tr class="separator:abcec3d6fab31a2b8114fff1f97b9c8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f5e333bb31f5287c1f839e8389fdd2"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a77f5e333bb31f5287c1f839e8389fdd2">p2p_scan</a> )(void *ctx, enum p2p_scan_type type, int <a class="el" href="structfreq.html">freq</a>, unsigned int num_req_dev_types, const u8 *req_dev_types, const u8 *dev_id, u16 pw_id)</td></tr>
<tr class="separator:a77f5e333bb31f5287c1f839e8389fdd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2c2d3b6af8877dfa035860e2460ba8"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a3e2c2d3b6af8877dfa035860e2460ba8">send_probe_resp</a> )(void *ctx, const struct <a class="el" href="structwpabuf.html">wpabuf</a> *buf, unsigned int <a class="el" href="structfreq.html">freq</a>)</td></tr>
<tr class="separator:a3e2c2d3b6af8877dfa035860e2460ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff915481aa22e85279111523bd37cb2"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a9ff915481aa22e85279111523bd37cb2">send_action</a> )(void *ctx, unsigned int <a class="el" href="structfreq.html">freq</a>, const u8 *dst, const u8 *src, const u8 *bssid, const u8 *buf, size_t len, unsigned int wait_time)</td></tr>
<tr class="separator:a9ff915481aa22e85279111523bd37cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ab6999d8a0d93affe8c1108130c447"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a36ab6999d8a0d93affe8c1108130c447">send_action_done</a> )(void *ctx)</td></tr>
<tr class="separator:a36ab6999d8a0d93affe8c1108130c447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba2599574d4003a3c356e0c42cae019"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#abba2599574d4003a3c356e0c42cae019">start_listen</a> )(void *ctx, unsigned int <a class="el" href="structfreq.html">freq</a>, unsigned int duration, const struct <a class="el" href="structwpabuf.html">wpabuf</a> *probe_resp_ie)</td></tr>
<tr class="separator:abba2599574d4003a3c356e0c42cae019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c55775a5d240b9d49c55349fbfe6e18"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a9c55775a5d240b9d49c55349fbfe6e18">stop_listen</a> )(void *ctx)</td></tr>
<tr class="separator:a9c55775a5d240b9d49c55349fbfe6e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2e67640653e5d986cc2b2dd161b4af"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a0f2e67640653e5d986cc2b2dd161b4af">get_noa</a> )(void *ctx, const u8 *interface_addr, u8 *buf, size_t buf_len)</td></tr>
<tr class="separator:a0f2e67640653e5d986cc2b2dd161b4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44483673ee940484fa6486dc43dda23b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a44483673ee940484fa6486dc43dda23b">dev_found</a> )(void *ctx, const u8 *addr, const struct <a class="el" href="structp2p__peer__info.html">p2p_peer_info</a> *info, int new_device)</td></tr>
<tr class="separator:a44483673ee940484fa6486dc43dda23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85871c8019352015fa9b232b9d7d8ba"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#ae85871c8019352015fa9b232b9d7d8ba">dev_lost</a> )(void *ctx, const u8 *<a class="el" href="structp2p__config.html#aaa2c0895e6785e03e48ed278dff7f95b">dev_addr</a>)</td></tr>
<tr class="separator:ae85871c8019352015fa9b232b9d7d8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cabc73120777765d9bf76b63bc9f04"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a57cabc73120777765d9bf76b63bc9f04">find_stopped</a> )(void *ctx)</td></tr>
<tr class="separator:a57cabc73120777765d9bf76b63bc9f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72059268c5c2d1069f40f99fdc6919f2"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a72059268c5c2d1069f40f99fdc6919f2">go_neg_req_rx</a> )(void *ctx, const u8 *src, u16 dev_passwd_id, u8 go_intent)</td></tr>
<tr class="separator:a72059268c5c2d1069f40f99fdc6919f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d0e547cdd2fb2b513e7aea0926c81e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#ad2d0e547cdd2fb2b513e7aea0926c81e">go_neg_completed</a> )(void *ctx, struct <a class="el" href="structp2p__go__neg__results.html">p2p_go_neg_results</a> *res)</td></tr>
<tr class="separator:ad2d0e547cdd2fb2b513e7aea0926c81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0184a5a884c48cd85289256d2660fc1"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#ad0184a5a884c48cd85289256d2660fc1">sd_request</a> )(void *ctx, int <a class="el" href="structfreq.html">freq</a>, const u8 *sa, u8 dialog_token, u16 update_indic, const u8 *tlvs, size_t tlvs_len)</td></tr>
<tr class="separator:ad0184a5a884c48cd85289256d2660fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2385b3e18e2eb82b0cdad629bad2fd5c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a2385b3e18e2eb82b0cdad629bad2fd5c">sd_response</a> )(void *ctx, const u8 *sa, u16 update_indic, const u8 *tlvs, size_t tlvs_len)</td></tr>
<tr class="separator:a2385b3e18e2eb82b0cdad629bad2fd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f724caa6eb8d323900b0906228f3dfc"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a3f724caa6eb8d323900b0906228f3dfc">prov_disc_req</a> )(void *ctx, const u8 *peer, u16 config_methods, const u8 *<a class="el" href="structp2p__config.html#aaa2c0895e6785e03e48ed278dff7f95b">dev_addr</a>, const u8 *<a class="el" href="structp2p__config.html#a70525a656382fdd5789b7a1eb6fb44ef">pri_dev_type</a>, const char *<a class="el" href="structp2p__config.html#a5ab49de1b6693f66f8b5a6d93aef5042">dev_name</a>, u16 supp_config_methods, u8 dev_capab, u8 group_capab, const u8 *group_id, size_t group_id_len)</td></tr>
<tr class="separator:a3f724caa6eb8d323900b0906228f3dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28705c8c0dbdbf8a4653d1d72dca044b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a28705c8c0dbdbf8a4653d1d72dca044b">prov_disc_resp</a> )(void *ctx, const u8 *peer, u16 config_methods)</td></tr>
<tr class="separator:a28705c8c0dbdbf8a4653d1d72dca044b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23ba6ae70724c829b323f025b646dd4"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#ad23ba6ae70724c829b323f025b646dd4">prov_disc_fail</a> )(void *ctx, const u8 *peer, enum p2p_prov_disc_status status, u32 adv_id, const u8 *adv_mac, const char *deferred_session_resp)</td></tr>
<tr class="separator:ad23ba6ae70724c829b323f025b646dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1847d34670f306a342b41acac749f088"><td class="memItemLeft" align="right" valign="top">u8(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a1847d34670f306a342b41acac749f088">invitation_process</a> )(void *ctx, const u8 *sa, const u8 *bssid, const u8 *go_dev_addr, const u8 *ssid, size_t ssid_len, int *go, u8 *group_bssid, int *force_freq, int persistent_group, const struct <a class="el" href="structp2p__channels.html">p2p_channels</a> *<a class="el" href="structp2p__config.html#ab109524c9ebfb53cc4fe538fae64019c">channels</a>, int dev_pw_id)</td></tr>
<tr class="separator:a1847d34670f306a342b41acac749f088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa248428e73e175b596e92ed829d70163"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#aa248428e73e175b596e92ed829d70163">invitation_received</a> )(void *ctx, const u8 *sa, const u8 *bssid, const u8 *ssid, size_t ssid_len, const u8 *go_dev_addr, u8 status, int op_freq)</td></tr>
<tr class="separator:aa248428e73e175b596e92ed829d70163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c40a3ca23c15f6e7b0d4a3513686e76"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a7c40a3ca23c15f6e7b0d4a3513686e76">invitation_result</a> )(void *ctx, int status, const u8 *bssid, const struct <a class="el" href="structp2p__channels.html">p2p_channels</a> *<a class="el" href="structp2p__config.html#ab109524c9ebfb53cc4fe538fae64019c">channels</a>, const u8 *addr, int <a class="el" href="structfreq.html">freq</a>, int peer_oper_freq)</td></tr>
<tr class="separator:a7c40a3ca23c15f6e7b0d4a3513686e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f8123808831501b6b31f92c15ca7e2"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a30f8123808831501b6b31f92c15ca7e2">go_connected</a> )(void *ctx, const u8 *<a class="el" href="structp2p__config.html#aaa2c0895e6785e03e48ed278dff7f95b">dev_addr</a>)</td></tr>
<tr class="separator:a30f8123808831501b6b31f92c15ca7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab2f75bf365f13c21342545541dc883"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a8ab2f75bf365f13c21342545541dc883">presence_resp</a> )(void *ctx, const u8 *src, u8 status, const u8 *noa, size_t noa_len)</td></tr>
<tr class="separator:a8ab2f75bf365f13c21342545541dc883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee0b6a4e05eb82af2507b6480c29b73"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#abee0b6a4e05eb82af2507b6480c29b73">is_concurrent_session_active</a> )(void *ctx)</td></tr>
<tr class="separator:abee0b6a4e05eb82af2507b6480c29b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684092ad44d7dfb5197dc147e43b1fe7"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a684092ad44d7dfb5197dc147e43b1fe7">is_p2p_in_progress</a> )(void *ctx)</td></tr>
<tr class="separator:a684092ad44d7dfb5197dc147e43b1fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e85e171c4b0f6fee51a5c92e0d047e0"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a3e85e171c4b0f6fee51a5c92e0d047e0">get_persistent_group</a> )(void *ctx, const u8 *addr, const u8 *ssid, size_t ssid_len, u8 *go_dev_addr, u8 *ret_ssid, size_t *ret_ssid_len, u8 *intended_iface_addr)</td></tr>
<tr class="separator:a3e85e171c4b0f6fee51a5c92e0d047e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00139e63d5881c1b43161539f333028"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#ae00139e63d5881c1b43161539f333028">get_go_info</a> )(void *ctx, u8 *intended_addr, u8 *ssid, size_t *ssid_len, int *group_iface, unsigned int *<a class="el" href="structfreq.html">freq</a>)</td></tr>
<tr class="separator:ae00139e63d5881c1b43161539f333028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a08ae66ef1a67c09f30bb39ea8387da"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a1a08ae66ef1a67c09f30bb39ea8387da">remove_stale_groups</a> )(void *ctx, const u8 *peer, const u8 *go, const u8 *ssid, size_t ssid_len)</td></tr>
<tr class="separator:a1a08ae66ef1a67c09f30bb39ea8387da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19b1725c2cd66055d388b5edb04c506"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#af19b1725c2cd66055d388b5edb04c506">p2ps_prov_complete</a> )(void *ctx, u8 status, const u8 *dev, const u8 *adv_mac, const u8 *ses_mac, const u8 *grp_mac, u32 adv_id, u32 ses_id, u8 conncap, int passwd_id, const u8 *persist_ssid, size_t persist_ssid_size, int response_done, int prov_start, const char *session_info, const u8 *feat_cap, size_t feat_cap_len, unsigned int <a class="el" href="structfreq.html">freq</a>, const u8 *group_ssid, size_t group_ssid_len)</td></tr>
<tr class="separator:af19b1725c2cd66055d388b5edb04c506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef07ab84483b7dc25dcec808094952d"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#acef07ab84483b7dc25dcec808094952d">prov_disc_resp_cb</a> )(void *ctx)</td></tr>
<tr class="separator:acef07ab84483b7dc25dcec808094952d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd3b9ccc25b879091dc95ad59fdff42"><td class="memItemLeft" align="right" valign="top">u8(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#a7bd3b9ccc25b879091dc95ad59fdff42">p2ps_group_capability</a> )(void *ctx, u8 incoming, u8 role, unsigned int *force_freq, unsigned int *pref_freq)</td></tr>
<tr class="separator:a7bd3b9ccc25b879091dc95ad59fdff42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d351798e3213b8e39e5983060eecac"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structp2p__config.html#ad6d351798e3213b8e39e5983060eecac">get_pref_freq_list</a> )(void *ctx, int go, unsigned int *len, unsigned int *freq_list)</td></tr>
<tr class="separator:ad6d351798e3213b8e39e5983060eecac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>struct <a class="el" href="structp2p__config.html">p2p_config</a> - P2P configuration</p>
<p>This configuration is provided to the P2P module during initialization with p2p_init(). </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a5ecd14d341af12b06cf3a8826e8ebdda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* p2p_config::cb_ctx</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>cb_ctx - Context to use with callback functions </p>

</div>
</div>
<a class="anchor" id="a4be0ff6a1f3da2597db0512f2c0abe52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 p2p_config::cfg_op_channel</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>cfg_op_channel - Whether op_channel is hardcoded in configuration </p>

</div>
</div>
<a class="anchor" id="a77c7e7676d4cdb62396d0c010d703104"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 p2p_config::channel</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>channel - Own listen channel </p>

</div>
</div>
<a class="anchor" id="ad29899639875e0d5cb27c5f8c724a188"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 p2p_config::channel_forced</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>channel_forced - the listen channel was forced by configuration or by control interface and cannot be overridden </p>

</div>
</div>
<a class="anchor" id="ab109524c9ebfb53cc4fe538fae64019c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structp2p__channels.html">p2p_channels</a> p2p_config::channels</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>channels - Own supported regulatory classes and channels</p>
<p>List of supposerted channels per regulatory class. The regulatory classes are defined in IEEE Std 802.11-2007 Annex J and the numbering of the clases depends on the configured country code. </p>

</div>
</div>
<a class="anchor" id="a902d89230147a02e5245513d7d5e0e2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structp2p__channels.html">p2p_channels</a> p2p_config::cli_channels</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>cli_channels - Additional client channels</p>
<p>This list of channels (if any) will be used when advertising local channels during GO Negotiation or Invitation for the cases where the local end may become the client. This may allow the peer to become a GO on additional channels if it supports these options. The main use case for this is to include passive-scan channels on devices that may not know their current location and have configured most channels to not allow initiation of radition (i.e., another device needs to take master responsibilities). </p>

</div>
</div>
<a class="anchor" id="aeefda9c6e8accee27515c32da7ac3f00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int p2p_config::concurrent_operations</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>concurrent_operations - Whether concurrent operations are supported </p>

</div>
</div>
<a class="anchor" id="a5e95c2907d3e12c38db01ad275d20a82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char p2p_config::country[3]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>country - Country code to use in P2P operations </p>

</div>
</div>
<a class="anchor" id="abcec3d6fab31a2b8114fff1f97b9c8d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* p2p_config::debug_print)(void *ctx, int level, const char *msg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>debug_print - Debug print : Callback context from cb_ctx : Debug verbosity level (MSG_*) : Debug message </p>

</div>
</div>
<a class="anchor" id="aaa2c0895e6785e03e48ed278dff7f95b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 p2p_config::dev_addr[ETH_ALEN]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dev_addr - P2P Device Address </p>

</div>
</div>
<a class="anchor" id="a44483673ee940484fa6486dc43dda23b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* p2p_config::dev_found)(void *ctx, const u8 *addr, const struct <a class="el" href="structp2p__peer__info.html">p2p_peer_info</a> *info, int new_device)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dev_found - Notification of a found P2P Device : Callback context from cb_ctx : Source address of the message triggering this notification : P2P peer information : Inform if the peer is newly found</p>
<p>This callback is used to notify that a new P2P Device has been found. This may happen, e.g., during Search state based on scan results or during Listen state based on receive Probe Request and Group Owner Negotiation Request. </p>

</div>
</div>
<a class="anchor" id="ae85871c8019352015fa9b232b9d7d8ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* p2p_config::dev_lost)(void *ctx, const u8 *<a class="el" href="structp2p__config.html#aaa2c0895e6785e03e48ed278dff7f95b">dev_addr</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dev_lost - Notification of a lost P2P Device : Callback context from cb_ctx : P2P Device Address of the lost P2P Device</p>
<p>This callback is used to notify that a P2P Device has been deleted. </p>

</div>
</div>
<a class="anchor" id="a5ab49de1b6693f66f8b5a6d93aef5042"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* p2p_config::dev_name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dev_name - Device Name </p>

</div>
</div>
<a class="anchor" id="a57cabc73120777765d9bf76b63bc9f04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* p2p_config::find_stopped)(void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>find_stopped - Notification of a p2p_find operation stopping : Callback context from cb_ctx </p>

</div>
</div>
<a class="anchor" id="ae00139e63d5881c1b43161539f333028"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* p2p_config::get_go_info)(void *ctx, u8 *intended_addr, u8 *ssid, size_t *ssid_len, int *group_iface, unsigned int *<a class="el" href="structfreq.html">freq</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get information about a possible local GO role : Callback context from cb_ctx : Buffer for returning intended GO interface address : Buffer for returning group SSID : Buffer for returning length of  : Buffer for returning whether a separate group interface would be used : Variable for returning the current operating frequency of a currently running P2P GO. Returns: 1 if GO info found, 0 otherwise</p>
<p>This is used to compose New Group settings (SSID, and intended address) during P2PS provisioning if results of provisioning <em>might</em> result in our being an autonomous GO. </p>

</div>
</div>
<a class="anchor" id="a0f2e67640653e5d986cc2b2dd161b4af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* p2p_config::get_noa)(void *ctx, const u8 *interface_addr, u8 *buf, size_t buf_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get_noa - Get current Notice of Absence attribute payload : Callback context from cb_ctx : P2P Interface Address of the GO : Buffer for returning NoA : Buffer length in octets Returns: Number of octets used in buf, 0 to indicate no NoA is being advertized, or -1 on failure</p>
<p>This function is used to fetch the current Notice of Absence attribute value from GO. </p>

</div>
</div>
<a class="anchor" id="a3e85e171c4b0f6fee51a5c92e0d047e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* p2p_config::get_persistent_group)(void *ctx, const u8 *addr, const u8 *ssid, size_t ssid_len, u8 *go_dev_addr, u8 *ret_ssid, size_t *ret_ssid_len, u8 *intended_iface_addr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if we have a persistent group we share with remote peer and allocate interface for this group if needed : Callback context from cb_ctx : Peer device address to search for : Persistent group SSID or NULL if any : Length of  : Buffer for returning GO P2P Device Address : Buffer for returning group SSID : Buffer for returning length of  : Buffer for returning intended iface address Returns: 1 if a matching persistent group was found, 0 otherwise </p>

</div>
</div>
<a class="anchor" id="ad6d351798e3213b8e39e5983060eecac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* p2p_config::get_pref_freq_list)(void *ctx, int go, unsigned int *len, unsigned int *freq_list)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get_pref_freq_list - Get preferred frequency list for an interface : Callback context from cb_ctx : Whether the use if for GO role : Length of freq_list in entries (both IN and OUT) : Buffer for returning the preferred frequencies (MHz) Returns: 0 on success, -1 on failure</p>
<p>This function can be used to query the preferred frequency list from the driver specific to a particular interface type. </p>

</div>
</div>
<a class="anchor" id="a30f8123808831501b6b31f92c15ca7e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* p2p_config::go_connected)(void *ctx, const u8 *<a class="el" href="structp2p__config.html#aaa2c0895e6785e03e48ed278dff7f95b">dev_addr</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>go_connected - Check whether we are connected to a GO : Callback context from cb_ctx : P2P Device Address of a GO Returns: 1 if we are connected as a P2P client to the specified GO or 0 if not. </p>

</div>
</div>
<a class="anchor" id="ad2d0e547cdd2fb2b513e7aea0926c81e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* p2p_config::go_neg_completed)(void *ctx, struct <a class="el" href="structp2p__go__neg__results.html">p2p_go_neg_results</a> *res)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>go_neg_completed - Notification of GO Negotiation results : Callback context from cb_ctx : GO Negotiation results</p>
<p>This callback is used to notify that Group Owner Negotiation has been completed. Non-zero struct <a class="el" href="structp2p__go__neg__results.html#a08cb16d686e55b297c2a8c4cdf1fdd04">p2p_go_neg_results::status</a> indicates failed negotiation. In case of success, this function is responsible for creating a new group interface (or using the existing interface depending on driver features), setting up the group interface in proper mode based on struct <a class="el" href="structp2p__go__neg__results.html#a2d519466fc6e4fc0366d917a26d3a317">p2p_go_neg_results::role_go</a> and initializing WPS provisioning either as a Registrar (if GO) or as an Enrollee. Successful WPS provisioning must be indicated by calling p2p_wps_success_cb(). The callee is responsible for timing out group formation if WPS provisioning cannot be completed successfully within 15 seconds. </p>

</div>
</div>
<a class="anchor" id="a72059268c5c2d1069f40f99fdc6919f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* p2p_config::go_neg_req_rx)(void *ctx, const u8 *src, u16 dev_passwd_id, u8 go_intent)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>go_neg_req_rx - Notification of a receive GO Negotiation Request : Callback context from cb_ctx : Source address of the message triggering this notification : WPS Device Password ID : Peer's GO Intent</p>
<p>This callback is used to notify that a P2P Device is requesting group owner negotiation with us, but we do not have all the necessary information to start GO Negotiation. This indicates that the local user has not authorized the connection yet by providing a PIN or PBC button press. This information can be provided with a call to p2p_connect(). </p>

</div>
</div>
<a class="anchor" id="a1847d34670f306a342b41acac749f088"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8(* p2p_config::invitation_process)(void *ctx, const u8 *sa, const u8 *bssid, const u8 *go_dev_addr, const u8 *ssid, size_t ssid_len, int *go, u8 *group_bssid, int *force_freq, int persistent_group, const struct <a class="el" href="structp2p__channels.html">p2p_channels</a> *<a class="el" href="structp2p__config.html#ab109524c9ebfb53cc4fe538fae64019c">channels</a>, int dev_pw_id)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>invitation_process - Optional callback for processing Invitations : Callback context from cb_ctx </p>
<dl class="section see"><dt>See Also</dt><dd>: Source address of the Invitation Request : P2P Group BSSID from the request or NULL if not included : GO Device Address from P2P Group ID : SSID from P2P Group ID : Length of ssid buffer in octets : Variable for returning whether the local end is GO in the group : Buffer for returning P2P Group BSSID (if local end GO) : Variable for returning forced frequency for the group : Whether this is an invitation to reinvoke a persistent group (instead of invitation to join an active group) : Available operating <a class="el" href="structp2p__config.html#ab109524c9ebfb53cc4fe538fae64019c">channels</a> for the group : Device Password ID for NFC static handover or -1 if not used Returns: Status code (P2P_SC_*)</dd></dl>
<p>This optional callback can be used to implement persistent reconnect by allowing automatic restarting of persistent groups without user interaction. If this callback is not implemented (i.e., is NULL), the received Invitation Request frames are replied with P2P_SC_REQ_RECEIVED status and indicated to upper layer with the <a class="el" href="structp2p__config.html#a7c40a3ca23c15f6e7b0d4a3513686e76">invitation_result()</a> callback.</p>
<p>If the requested parameters are acceptable and the group is known, P2P_SC_SUCCESS may be returned. If the requested group is unknown, P2P_SC_FAIL_UNKNOWN_GROUP should be returned. P2P_SC_REQ_RECEIVED can be returned if there is not enough data to provide immediate response, i.e., if some sort of user interaction is needed. The <a class="el" href="structp2p__config.html#aa248428e73e175b596e92ed829d70163">invitation_received()</a> callback will be called in that case immediately after this call. </p>

</div>
</div>
<a class="anchor" id="aa248428e73e175b596e92ed829d70163"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* p2p_config::invitation_received)(void *ctx, const u8 *sa, const u8 *bssid, const u8 *ssid, size_t ssid_len, const u8 *go_dev_addr, u8 status, int op_freq)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>invitation_received - Callback on Invitation Request RX : Callback context from cb_ctx </p>
<dl class="section see"><dt>See Also</dt><dd>: Source address of the Invitation Request : P2P Group BSSID or NULL if not received : SSID of the group : Length of ssid in octets : GO Device Address : Response Status : Operational frequency for the group</dd></dl>
<p>This callback is used to indicate sending of an Invitation Response for a received Invitation Request. If status == 0 (success), the upper layer code is responsible for starting the group. status == 1 indicates need to get user authorization for the group. Other status values indicate that the invitation request was rejected. </p>

</div>
</div>
<a class="anchor" id="a7c40a3ca23c15f6e7b0d4a3513686e76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* p2p_config::invitation_result)(void *ctx, int status, const u8 *bssid, const struct <a class="el" href="structp2p__channels.html">p2p_channels</a> *<a class="el" href="structp2p__config.html#ab109524c9ebfb53cc4fe538fae64019c">channels</a>, const u8 *addr, int <a class="el" href="structfreq.html">freq</a>, int peer_oper_freq)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>invitation_result - Callback on Invitation result : Callback context from cb_ctx : Negotiation result (Status Code) : P2P Group BSSID or NULL if not received : Available operating channels for the group : Peer address : Frequency (in MHz) indicated during invitation or 0 : Operating frequency (in MHz) advertized by the peer during invitation or 0</p>
<p>This callback is used to indicate result of an Invitation procedure started with a call to p2p_invite(). The indicated status code is the value received from the peer in Invitation Response with 0 (P2P_SC_SUCCESS) indicating success or -1 to indicate a timeout or a local failure in transmitting the Invitation Request. </p>

</div>
</div>
<a class="anchor" id="abee0b6a4e05eb82af2507b6480c29b73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* p2p_config::is_concurrent_session_active)(void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_concurrent_session_active - Check whether concurrent session is active on other virtual interfaces : Callback context from cb_ctx Returns: 1 if concurrent session is active on other virtual interface or 0 if not. </p>

</div>
</div>
<a class="anchor" id="a684092ad44d7dfb5197dc147e43b1fe7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* p2p_config::is_p2p_in_progress)(void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_p2p_in_progress - Check whether P2P operation is in progress : Callback context from cb_ctx Returns: 1 if P2P operation (e.g., group formation) is in progress or 0 if not. </p>

</div>
</div>
<a class="anchor" id="adbbfb310287390f176dc7394b3361094"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int p2p_config::max_listen</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>max_listen - Maximum listen duration in ms </p>

</div>
</div>
<a class="anchor" id="aeb9f4c368b4ebe83d7795358ee4faebe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t p2p_config::max_peers</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>max_peers - Maximum number of discovered peers to remember</p>
<p>If more peers are discovered, older entries will be removed to make room for the new ones. </p>

</div>
</div>
<a class="anchor" id="aac6139b8ce7a4478035d31397588a65d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int p2p_config::num_pref_chan</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>num_pref_chan - Number of pref_chan entries </p>

</div>
</div>
<a class="anchor" id="a29d3a4014e072c43616fdf0ee427820b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t p2p_config::num_sec_dev_types</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>num_sec_dev_types - Number of sec_dev_type entries </p>

</div>
</div>
<a class="anchor" id="ad434b4bdab005781be88cf55a47369af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 p2p_config::op_channel</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>op_channel - Own operational channel </p>

</div>
</div>
<a class="anchor" id="ae65cc8fc867118291fea93d1b367e18d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 p2p_config::op_reg_class</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Regulatory class for own operational channel </p>

</div>
</div>
<a class="anchor" id="a40051f8d8fd59fbd8f66eab6e726017f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int p2p_config::p2p_intra_bss</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>p2p_intra_bss - Intra BSS communication is supported </p>

</div>
</div>
<a class="anchor" id="a77f5e333bb31f5287c1f839e8389fdd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* p2p_config::p2p_scan)(void *ctx, enum p2p_scan_type type, int <a class="el" href="structfreq.html">freq</a>, unsigned int num_req_dev_types, const u8 *req_dev_types, const u8 *dev_id, u16 pw_id)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>p2p_scan - Request a P2P scan/search : Callback context from cb_ctx : Scan type : Specific frequency (MHz) to scan or 0 for no restriction : Number of requested device types : Array containing requested device types : Device ID to search for or NULL to find all devices : Device Password ID Returns: 0 on success, -1 on failure</p>
<p>This callback function is used to request a P2P scan or search operation to be completed. Type type argument specifies which type of scan is to be done.  indicates that only the social channels (1, 6, 11) should be scanned.  indicates that all channels are to be scanned.  request a scan of a single channel specified by freq.  request scan of all the social channels plus one extra channel specified by freq.</p>
<p>The full scan is used for the initial scan to find group owners from all. The other types are used during search phase scan of the social channels (with potential variation if the Listen channel of the target peer is known or if other channels are scanned in steps).</p>
<p>The scan results are returned after this call by calling p2p_scan_res_handler() for each scan result that has a P2P IE and then calling p2p_scan_res_handled() to indicate that all scan results have been indicated. </p>

</div>
</div>
<a class="anchor" id="a7bd3b9ccc25b879091dc95ad59fdff42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8(* p2p_config::p2ps_group_capability)(void *ctx, u8 incoming, u8 role, unsigned int *force_freq, unsigned int *pref_freq)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>p2ps_group_capability - Determine group capability : Callback context from cb_ctx : Peer requested roles, expressed with P2PS_SETUP_* bitmap. : Local roles, expressed with P2PS_SETUP_* bitmap. : Variable for returning forced frequency for the group. : Variable for returning preferred frequency for the group. Returns: P2PS_SETUP_* bitmap of group capability result.</p>
<p>This function can be used to determine group capability and frequencies based on information from P2PS PD exchange and the current state of ongoing groups and driver capabilities. </p>

</div>
</div>
<a class="anchor" id="af19b1725c2cd66055d388b5edb04c506"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* p2p_config::p2ps_prov_complete)(void *ctx, u8 status, const u8 *dev, const u8 *adv_mac, const u8 *ses_mac, const u8 *grp_mac, u32 adv_id, u32 ses_id, u8 conncap, int passwd_id, const u8 *persist_ssid, size_t persist_ssid_size, int response_done, int prov_start, const char *session_info, const u8 *feat_cap, size_t feat_cap_len, unsigned int <a class="el" href="structfreq.html">freq</a>, const u8 *group_ssid, size_t group_ssid_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>p2ps_prov_complete - P2PS provisioning complete</p>
<p>When P2PS provisioning completes (successfully or not) we must transmit all of the results to the upper layers. </p>

</div>
</div>
<a class="anchor" id="a6c1e2511fa80afba207beb60e748741e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int p2p_config::passphrase_len</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>passphrase_len - Passphrase length (8..63)</p>
<p>This parameter controls the length of the random passphrase that is generated at the GO. </p>

</div>
</div>
<a class="anchor" id="ae903a0b0eda0c75cfe9df44767fb2566"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structp2p__channel.html">p2p_channel</a>* p2p_config::pref_chan</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>pref_chan - Preferred channels for GO Negotiation </p>

</div>
</div>
<a class="anchor" id="a8ab2f75bf365f13c21342545541dc883"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* p2p_config::presence_resp)(void *ctx, const u8 *src, u8 status, const u8 *noa, size_t noa_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>presence_resp - Callback on Presence Response : Callback context from cb_ctx : Source address (GO's P2P Interface Address) : Result of the request (P2P_SC_*) : Returned NoA value : Length of the NoA buffer in octets </p>

</div>
</div>
<a class="anchor" id="a70525a656382fdd5789b7a1eb6fb44ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 p2p_config::pri_dev_type[8]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>pri_dev_type - Primary Device Type (see WPS) </p>

</div>
</div>
<a class="anchor" id="ad23ba6ae70724c829b323f025b646dd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* p2p_config::prov_disc_fail)(void *ctx, const u8 *peer, enum p2p_prov_disc_status status, u32 adv_id, const u8 *adv_mac, const char *deferred_session_resp)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>prov_disc_fail - Callback on Provision Discovery failure : Callback context from cb_ctx : Source address of the response : Cause of failure, will not be P2P_PROV_DISC_SUCCESS : If non-zero, then the adv_id of the PD Request : P2P Device Address of the advertizer : Deferred session response sent by advertizer</p>
<p>This callback is used to indicate either a failure or no response to an earlier provision discovery request.</p>
<p>This callback handler can be set to NULL if provision discovery is not used or failures do not need to be indicated. </p>

</div>
</div>
<a class="anchor" id="a3f724caa6eb8d323900b0906228f3dfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* p2p_config::prov_disc_req)(void *ctx, const u8 *peer, u16 config_methods, const u8 *<a class="el" href="structp2p__config.html#aaa2c0895e6785e03e48ed278dff7f95b">dev_addr</a>, const u8 *<a class="el" href="structp2p__config.html#a70525a656382fdd5789b7a1eb6fb44ef">pri_dev_type</a>, const char *<a class="el" href="structp2p__config.html#a5ab49de1b6693f66f8b5a6d93aef5042">dev_name</a>, u16 supp_config_methods, u8 dev_capab, u8 group_capab, const u8 *group_id, size_t group_id_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>prov_disc_req - Callback on Provisiong Discovery Request : Callback context from cb_ctx : Source address of the request : Requested WPS Config Method : P2P Device Address of the found P2P Device : Primary Device Type : Device Name : Supported configuration Methods : Device Capabilities : Group Capabilities : P2P Group ID (or NULL if not included) : Length of P2P Group ID</p>
<p>This callback is used to indicate reception of a Provision Discovery Request frame that the P2P module accepted. </p>

</div>
</div>
<a class="anchor" id="a28705c8c0dbdbf8a4653d1d72dca044b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* p2p_config::prov_disc_resp)(void *ctx, const u8 *peer, u16 config_methods)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>prov_disc_resp - Callback on Provisiong Discovery Response : Callback context from cb_ctx : Source address of the response : Value from p2p_prov_disc_req() or 0 on failure</p>
<p>This callback is used to indicate reception of a Provision Discovery Response frame for a pending request scheduled with p2p_prov_disc_req(). This callback handler can be set to NULL if provision discovery is not used. </p>

</div>
</div>
<a class="anchor" id="acef07ab84483b7dc25dcec808094952d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* p2p_config::prov_disc_resp_cb)(void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>prov_disc_resp_cb - Callback for indicating completion of PD Response : Callback context from cb_ctx Returns: 1 if operation was started, 0 otherwise</p>
<p>This callback can be used to perform any pending actions after provisioning. It is mainly used for P2PS pending group creation. </p>

</div>
</div>
<a class="anchor" id="a815704a6c088a5f78358288b651864a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 p2p_config::reg_class</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>reg_class - Regulatory class for own listen channel </p>

</div>
</div>
<a class="anchor" id="a1a08ae66ef1a67c09f30bb39ea8387da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* p2p_config::remove_stale_groups)(void *ctx, const u8 *peer, const u8 *go, const u8 *ssid, size_t ssid_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>remove_stale_groups - Remove stale P2PS groups</p>
<p>Because P2PS stages <em>potential</em> GOs, and remote devices can remove credentials unilaterally, we need to make sure we don't let stale unusable groups build up. </p>

</div>
</div>
<a class="anchor" id="ad0184a5a884c48cd85289256d2660fc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* p2p_config::sd_request)(void *ctx, int <a class="el" href="structfreq.html">freq</a>, const u8 *sa, u8 dialog_token, u16 update_indic, const u8 *tlvs, size_t tlvs_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sd_request - Callback on Service Discovery Request : Callback context from cb_ctx : Frequency (in MHz) of the channel </p>
<dl class="section see"><dt>See Also</dt><dd>: Source address of the request : Dialog token : Service Update Indicator from the source of request : P2P Service Request TLV(s) : Length of tlvs buffer in octets</dd></dl>
<p>This callback is used to indicate reception of a service discovery request. Response to the query must be indicated by calling p2p_sd_response() with the context information from the arguments to this callback function.</p>
<p>This callback handler can be set to NULL to indicate that service discovery is not supported. </p>

</div>
</div>
<a class="anchor" id="a2385b3e18e2eb82b0cdad629bad2fd5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* p2p_config::sd_response)(void *ctx, const u8 *sa, u16 update_indic, const u8 *tlvs, size_t tlvs_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sd_response - Callback on Service Discovery Response : Callback context from cb_ctx </p>
<dl class="section see"><dt>See Also</dt><dd>: Source address of the request : Service Update Indicator from the source of response : P2P Service Response TLV(s) : Length of tlvs buffer in octets</dd></dl>
<p>This callback is used to indicate reception of a service discovery response. This callback handler can be set to NULL if no service discovery requests are used. The information provided with this call is replies to the queries scheduled with p2p_sd_request(). </p>

</div>
</div>
<a class="anchor" id="a81bed5e8fce37a4bf11f2f43d12aac33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 p2p_config::sec_dev_type[P2P_SEC_DEVICE_TYPES][8]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sec_dev_type - Optional secondary device types </p>

</div>
</div>
<a class="anchor" id="a9ff915481aa22e85279111523bd37cb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* p2p_config::send_action)(void *ctx, unsigned int <a class="el" href="structfreq.html">freq</a>, const u8 *dst, const u8 *src, const u8 *bssid, const u8 *buf, size_t len, unsigned int wait_time)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>send_action - Transmit an Action frame : Callback context from cb_ctx : Frequency in MHz for the channel on which to transmit : Destination MAC address (Address 1) : Source MAC address (Address 2) : BSSID (Address 3) : Frame body (starting from Category field) : Length of buf in octets : How many msec to wait for a response frame Returns: 0 on success, -1 on failure</p>
<p>The Action frame may not be transmitted immediately and the status of the transmission must be reported by calling p2p_send_action_cb() once the frame has either been transmitted or it has been dropped due to excessive retries or other failure to transmit. </p>

</div>
</div>
<a class="anchor" id="a36ab6999d8a0d93affe8c1108130c447"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* p2p_config::send_action_done)(void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>send_action_done - Notify that Action frame sequence was completed : Callback context from cb_ctx</p>
<p>This function is called when the Action frame sequence that was started with <a class="el" href="structp2p__config.html#a9ff915481aa22e85279111523bd37cb2">send_action()</a> has been completed, i.e., when there is no need to wait for a response from the destination peer anymore. </p>

</div>
</div>
<a class="anchor" id="a3e2c2d3b6af8877dfa035860e2460ba8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* p2p_config::send_probe_resp)(void *ctx, const struct <a class="el" href="structwpabuf.html">wpabuf</a> *buf, unsigned int <a class="el" href="structfreq.html">freq</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>send_probe_resp - Transmit a Probe Response frame : Callback context from cb_ctx : Probe Response frame (including the header and body) : Forced frequency (in MHz) to use or 0. Returns: 0 on success, -1 on failure</p>
<p>This function is used to reply to Probe Request frames that were indicated with a call to p2p_probe_req_rx(). The response is to be sent on the same channel, unless otherwise specified, or to be dropped if the driver is not listening to Probe Request frames anymore.</p>
<p>Alternatively, the responsibility for building the Probe Response frames in Listen state may be in another system component in which case this function need to be implemented (i.e., the function pointer can be NULL). The WPS and P2P IEs to be added for Probe Response frames in such a case are available from the <a class="el" href="structp2p__config.html#abba2599574d4003a3c356e0c42cae019">start_listen()</a> callback. It should be noted that the received Probe Request frames must be indicated by calling p2p_probe_req_rx() even if this <a class="el" href="structp2p__config.html#a3e2c2d3b6af8877dfa035860e2460ba8">send_probe_resp()</a> is not used. </p>

</div>
</div>
<a class="anchor" id="a89f937e672c4ef68a2fa75611ad19613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 p2p_config::ssid_postfix[SSID_MAX_LEN-9]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ssid_postfix - Postfix data to add to the SSID</p>
<p>This data will be added to the end of the SSID after the DIRECT-&lt;random two="" octets&gt;=""&gt; prefix. </p>

</div>
</div>
<a class="anchor" id="a42f2888ee0c102f10a65ead133779f6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t p2p_config::ssid_postfix_len</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ssid_postfix_len - Length of the ssid_postfix data </p>

</div>
</div>
<a class="anchor" id="abba2599574d4003a3c356e0c42cae019"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* p2p_config::start_listen)(void *ctx, unsigned int <a class="el" href="structfreq.html">freq</a>, unsigned int duration, const struct <a class="el" href="structwpabuf.html">wpabuf</a> *probe_resp_ie)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>start_listen - Start Listen state : Callback context from cb_ctx : Frequency of the listen channel in MHz : Duration for the Listen state in milliseconds : IE(s) to be added to Probe Response frames Returns: 0 on success, -1 on failure</p>
<p>This Listen state may not start immediately since the driver may have other pending operations to complete first. Once the Listen state has started, p2p_listen_cb() must be called to notify the P2P module. Once the Listen state is stopped, p2p_listen_end() must be called to notify the P2P module that the driver is not in the Listen state anymore.</p>
<p>If the <a class="el" href="structp2p__config.html#a3e2c2d3b6af8877dfa035860e2460ba8">send_probe_resp()</a> is not used for generating the response, the IEs from probe_resp_ie need to be added to the end of the Probe Response frame body. If <a class="el" href="structp2p__config.html#a3e2c2d3b6af8877dfa035860e2460ba8">send_probe_resp()</a> is used, the probe_resp_ie information can be ignored. </p>

</div>
</div>
<a class="anchor" id="a9c55775a5d240b9d49c55349fbfe6e18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* p2p_config::stop_listen)(void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>stop_listen - Stop Listen state : Callback context from cb_ctx</p>
<p>This callback can be used to stop a Listen state operation that was previously requested with <a class="el" href="structp2p__config.html#abba2599574d4003a3c356e0c42cae019">start_listen()</a>. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>src/p2p/<a class="el" href="p2p_8h_source.html">p2p.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 12 2017 21:13:46 for Ethanol modification of Hostapd by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
